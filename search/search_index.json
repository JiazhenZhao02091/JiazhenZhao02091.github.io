{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About me \u4e2a\u4eba\u4ecb\u7ecd My name is Jiazhen Zhao . I am a male born in 2002 and currently studying at the School of Computer Science and Software Engineering at Nanyang Institute of Technology. My email addresses are 873694994@qq.com and zhaojiazhen12318@gmail.com . My GitHub profile can be found at https://github.com/JiazhenZhao02091 . Nice to meet you! \u6211\u53eb \u8d75\u5bb6\u632f \uff0c\u6027\u522b\u7537\uff0c02\u5e74\u51fa\u751f\uff0c\u76ee\u524d\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662\u8ba1\u7b97\u673a\u4e0e\u8f6f\u4ef6\u5b66\u9662\uff0c\u6211\u7684\u90ae\u7bb1\uff1a 873694994@qq.com && zhaojiazhen12318@gmail.com \uff0cGitHub\u4e3b\u9875\uff1a https://github.com/JiazhenZhao02091 ,\u5f88\u9ad8\u5174\u8ba4\u8bc6\u4f60\uff01 \u6559\u80b2\u80cc\u666f 2021-\u81f3\u4eca\uff1a\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662 \u7231\u597d \u6253\u6e38\u620f\uff08FPS\uff0cMOBA\u7b49\uff09 \u8dd1\u6b65 \u4e52\u4e53\u7403\u3001\u5409\u4ed6","title":"Home"},{"location":"#about-me","text":"","title":"About me"},{"location":"#_1","text":"My name is Jiazhen Zhao . I am a male born in 2002 and currently studying at the School of Computer Science and Software Engineering at Nanyang Institute of Technology. My email addresses are 873694994@qq.com and zhaojiazhen12318@gmail.com . My GitHub profile can be found at https://github.com/JiazhenZhao02091 . Nice to meet you! \u6211\u53eb \u8d75\u5bb6\u632f \uff0c\u6027\u522b\u7537\uff0c02\u5e74\u51fa\u751f\uff0c\u76ee\u524d\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662\u8ba1\u7b97\u673a\u4e0e\u8f6f\u4ef6\u5b66\u9662\uff0c\u6211\u7684\u90ae\u7bb1\uff1a 873694994@qq.com && zhaojiazhen12318@gmail.com \uff0cGitHub\u4e3b\u9875\uff1a https://github.com/JiazhenZhao02091 ,\u5f88\u9ad8\u5174\u8ba4\u8bc6\u4f60\uff01","title":"\u4e2a\u4eba\u4ecb\u7ecd"},{"location":"#_2","text":"2021-\u81f3\u4eca\uff1a\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662","title":"\u6559\u80b2\u80cc\u666f"},{"location":"#_3","text":"\u6253\u6e38\u620f\uff08FPS\uff0cMOBA\u7b49\uff09 \u8dd1\u6b65 \u4e52\u4e53\u7403\u3001\u5409\u4ed6","title":"\u7231\u597d"},{"location":"about/","text":"About me \u4e2a\u4eba\u4ecb\u7ecd My name is Jiazhen Zhao . I am a male born in 2002 and currently studying at the School of Computer Science and Software Engineering at Nanyang Institute of Technology. My email addresses are 873694994@qq.com and zhaojiazhen12318@gmail.com . My GitHub profile can be found at https://github.com/JiazhenZhao02091 . Nice to meet you! \u6211\u53eb \u8d75\u5bb6\u632f \uff0c\u6027\u522b\u7537\uff0c02\u5e74\u51fa\u751f\uff0c\u76ee\u524d\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662\u8ba1\u7b97\u673a\u4e0e\u8f6f\u4ef6\u5b66\u9662\uff0c\u6211\u7684\u90ae\u7bb1\uff1a 873694994@qq.com && zhaojiazhen12318@gmail.com \uff0cGitHub\u4e3b\u9875\uff1a https://github.com/JiazhenZhao02091 ,\u5f88\u9ad8\u5174\u8ba4\u8bc6\u4f60\uff01 \u6559\u80b2\u80cc\u666f 2021-\u81f3\u4eca\uff1a\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662 \u7231\u597d \u6253\u6e38\u620f\uff08FPS\uff0cMOBA\u7b49\uff09 \u8dd1\u6b65 \u4e52\u4e53\u7403\u3001\u5409\u4ed6","title":"About"},{"location":"about/#about-me","text":"","title":"About me"},{"location":"about/#_1","text":"My name is Jiazhen Zhao . I am a male born in 2002 and currently studying at the School of Computer Science and Software Engineering at Nanyang Institute of Technology. My email addresses are 873694994@qq.com and zhaojiazhen12318@gmail.com . My GitHub profile can be found at https://github.com/JiazhenZhao02091 . Nice to meet you! \u6211\u53eb \u8d75\u5bb6\u632f \uff0c\u6027\u522b\u7537\uff0c02\u5e74\u51fa\u751f\uff0c\u76ee\u524d\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662\u8ba1\u7b97\u673a\u4e0e\u8f6f\u4ef6\u5b66\u9662\uff0c\u6211\u7684\u90ae\u7bb1\uff1a 873694994@qq.com && zhaojiazhen12318@gmail.com \uff0cGitHub\u4e3b\u9875\uff1a https://github.com/JiazhenZhao02091 ,\u5f88\u9ad8\u5174\u8ba4\u8bc6\u4f60\uff01","title":"\u4e2a\u4eba\u4ecb\u7ecd"},{"location":"about/#_2","text":"2021-\u81f3\u4eca\uff1a\u5c31\u8bfb\u4e8e\u5357\u9633\u7406\u5de5\u5b66\u9662","title":"\u6559\u80b2\u80cc\u666f"},{"location":"about/#_3","text":"\u6253\u6e38\u620f\uff08FPS\uff0cMOBA\u7b49\uff09 \u8dd1\u6b65 \u4e52\u4e53\u7403\u3001\u5409\u4ed6","title":"\u7231\u597d"},{"location":"useGuide/","text":"Makedocs \u5e38\u7528\u6307\u4ee4 make -- mk \u521b\u5efa\u9879\u76ee makedocs new project \u542f\u52a8\u670d\u52a1 makedocs serve \u751f\u6210\u7f51\u7ad9(site/) makedocs build \u5220\u9664\u5197\u4f59\u6587\u4ef6 mkdocs build --clean help makedocs --help makedocs build --help","title":"UseGuide"},{"location":"useGuide/#makedocs","text":"make -- mk \u521b\u5efa\u9879\u76ee makedocs new project \u542f\u52a8\u670d\u52a1 makedocs serve \u751f\u6210\u7f51\u7ad9(site/) makedocs build \u5220\u9664\u5197\u4f59\u6587\u4ef6 mkdocs build --clean help makedocs --help makedocs build --help","title":"Makedocs \u5e38\u7528\u6307\u4ee4"},{"location":"algorithm/dataStructure/","text":"dataStruct \u5e38\u89c1\u6570\u636e\u7ed3\u6784","title":"dataStructure"},{"location":"algorithm/dataStructure/#datastruct","text":"\u5e38\u89c1\u6570\u636e\u7ed3\u6784","title":"dataStruct"},{"location":"algorithm/graph/","text":"\u56fe\u8bba\u7b97\u6cd5 \u6700\u77ed\u8def \u80fd\u7528dijkstra\u7684\u5c31\u522b\u7528spfa Dijkstra \u7b97\u6cd5 \u9898\u89e3 \u6734\u7d20\u7528\u90bb\u63a5\u77e9\u9635\u5b58\u50a8 // \u7a20\u5bc6\u56fe \u70b9\u5c11\u7ebf\u591a 1.\u5faa\u73af n \u6b21 2.\u627e\u5230\u4e00\u4e2a t \u7528\u6765\u4ee3\u8868\u5f53\u524d\u6240\u6709\u70b9\u5230\u76ee\u524d\u70b9\u7684\u6700\u77ed\u8ddd\u79bb 3.\u7528 t \u6765\u66f4\u65b0\u5230\u8fd9\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb #include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 550; int g[N][N]; int dist[N]; bool st[N]; int n,m; void dijkstra() { memset(dist,0x3f,sizeof dist); dist[1] = 0; for(int i = 0 ; i < n; i ++) { int t = -1; for(int j = 1; j <= n ; j ++) if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j ; for(int j = 1 ;j <= n ; j ++) dist[j] = min(dist[j],dist[t] + g[t][j]); st[t] = true; } } int main(void) { memset(g,0x3f,sizeof g); cin >> n >> m ; while(m --) { int a,b,c; cin >> a >> b >> c; g[a][b] = min(g[a][b],c); } dijkstra(); if(dist[n] == 0x3f3f3f3f) cout << -1 << endl; else cout << dist[n] << endl; return 0; } \u4f18\u5316\u7248\u7684dijkstr \u7b97\u6cd5 \u7a00\u758f\u56fe \u7528\u90bb\u63a5\u77e9\u9635\u6765\u5b58\u50a8 \u7528\u5806\u8fdb\u884c\u4f18\u5316 \u6bcf\u6b21\u53d6\u6700\u77ed\u503c\u7684\u65f6\u5019 \u53d6\u5806\u9876\u5143\u7d20 \u76f8\u5f53\u4e8e\u662f\u7701\u7565\u4e86\u6734\u7d20\u7248dijkstra \u7684\u627e\u5230\u8ddd\u79bb\u5f53\u524d\u70b9\u6700\u77ed\u8ddd\u79bb\u8fd9\u4e00\u6b65\uff1b\uff1b \u4ee3\u66ff\u4e0a\u8fb9\u7684\u7b2c\u4e00\u4e8c\u6b65 \u7136\u540e\u66f4\u65b0\u6240\u6709\u5806\u7684\u8ddd\u79bb \u7528\u4e00\u4e2a pair \u6570\u7ec4\u6765\u5b58\u50a8\u5230\u8d77\u70b9\u7684\u8ddd\u79bb\u548c\u5f53\u524d\u70b9\u7684\u7f16\u53f7 \u7528\u90bb\u63a5\u8868\u904d\u5386\u6240\u6709\u5230\u8fbe\u7684\u70b9 \u5e76\u5bf9\u5176\u8fdb\u884c\u5224\u65ad \u5982\u679c\u5c0f\u4e8e \u5e76\u4e14\u8be5\u503c\u5e76\u672a\u88ab\u4f7f\u7528\u8fc7 \u5373 st \u4e3a false \u53ef\u4ee5\u8fdb\u884c\u66f4\u65b0 \u5c31\u628a\u8be5\u503c\u548c\u8ddd\u79bb\u63a8\u8fdb heap \u6570\u7ec4\u4e2d \u8fd9\u91cc \u4e0e spfa \u7b97\u6cd5\u8fdb\u884c\u4e2a\u533a\u5206 dijsktra \u7b97\u6cd5\u4e00\u822c\u5728\u53d6\u5f97\u7f16\u53f7\u540e\u5c31\u8fdb\u884c\u5224\u65ad \u662f\u5426\u8fdb\u884c continue \u73af\u8282 spfa \u7b97\u6cd5 \u5219\u5728 for \u5faa\u73af\u548c if \u5faa\u73af \u4e4b\u540e\u5224\u65ad\u8be5\u503c\u662f\u5426\u4f7f\u7528\u8fc7 dijkstra\u4fdd\u8bc1\u4e86\u6bcf\u4e2a\u70b9\u53ea\u4f1a\u88ab\u4f7f\u7528\u4e00\u6b21\uff0c\u800cspfa\u5219\u4e00\u4e2a\u70b9\u53ef\u80fd\u88ab\u591a\u6b21\u4f7f\u7528 \u200b SPFA\u53ef\u4ee5\u5904\u7406\u8d1f\u6743\u8fb9\uff0c\u4f46\u662f\u4e0d\u80fd\u5904\u7406\u6709\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff1b\u800cDijkstra\u4e0d\u80fd\u5904\u7406\u5e26\u6709\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff0c\u56e0\u4e3aDijkstra\u7b97\u6cd5\u5728\u8ba1\u7b97\u6700\u77ed\u8def\u5f84\u65f6\uff0c\u4e0d\u4f1a\u56e0\u4e3a\u8d1f\u8fb9\u7684\u51fa\u73b0\u800c\u66f4\u65b0\u5df2\u7ecf\u8ba1\u7b97\u8fc7(\u6536\u5f55\u8fc7)\u7684\u9876\u70b9\u7684\u8def\u5f84\u957f\u5ea6\uff1b \u200b \u603b\u7ed3\u4e00\u4e0b\uff1aBellman-ford\u53ef\u4ee5\u5904\u7406\u4efb\u610f\u5e26\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u73af\u7684\u56fe\uff0cSPFA\u53ef\u4ee5\u5904\u7406\u5e26\u8d1f\u6743\u8fb9\u7684\u56fe\uff0cDijkstra\u53ea\u80fd\u5904\u7406\u5e26\u6b63\u6743\u8fb9\u7684\u56fe\uff1b\u5f53\u7136\uff0c\u4ece\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u6548\u7387\u6765\u8bb2\uff0c\u662f\u53cd\u8fc7\u6765\u7684\uff0chh #include <iostream> #include <algorithm> #include <queue> #include <cstring> using namespace std; typedef pair<int,int> PII; const int N = 1e6 + 10; int h[N],e[N],ne[N],w[N],idx; int dist[N]; bool st[N]; int n,m; void add(int a,int b,int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++; } void dijkstra() { memset(dist,0x3f,sizeof dist); priority_queue <PII,vector<PII>,greater<PII> >heap; dist[1] = 0; heap.push({0,1}); while(heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second; int s = t.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1 ; i = ne[i]) { int j = e[i]; if(dist[j] > dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j],j}); } } } } int main(void) { cin >> n >> m ; memset(h,-1,sizeof h); while(m--) { int a,b,c; cin >> a >> b >> c ; add(a,b,c); } dijkstra(); if(dist[n] == 0x3f3f3f3f) cout << -1 << endl; else cout << dist[n] << endl; return 0; } Bellman_ford \u7b97\u6cd5 \u7528\u4e8e\u5904\u7406\u5b58\u5728\u8d1f\u6743\u8fb9\u7684\u73af\u8282 \u5e76\u4e14\u5b58\u5728 \u5224\u65ad\u81f3\u5c11\u5728\u51e0\u6761\u8fb9\u5b9e\u73b0 \u5229\u7528\u7ed3\u6784\u4f53\u6765\u5b58\u50a8 \u7b2c\u4e00\u5c42 for \u5faa\u73af\u4ee3\u8868\u6700\u77ed\u51e0\u6761\u8fb9 \u63a5\u4e0b\u6765\u5bf9\u6240\u6709\u7684\u8fb9\u8fdb\u884c\u904d\u5386\uff0c\u7528 struct \u6765\u5bf9\u6bcf\u6761\u8fb9\u53d6\u6700\u77ed\u7684\u8def\u5f84 \u4e3a\u4e86\u907f\u514d\u51fa \u884c\u6bd4\u5bf9 #include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 550,M = 10010; struct Edge { int a,b,c; }edges[M]; int n,m,k; int dist[N]; int last[N]; void bellman_ford() { memset(dist,0x3f,sizeof dist); dist[1] = 0; for(int i = 0 ; i < k ;i ++) { memcpy(last,dist,sizeof dist); for(int j = 0 ; j< m ; j ++) { auto e = edges[j]; dist[e.b] = min(dist[e.b], last[e.a] + e.c); } } } int main(void) { cin >> n >> m >> k; for(int i = 0;i<m;i++) { int x,y,z; cin >> x >> y >> z; edges[i] = {x,y,z}; } bellman_ford(); if (dist[n] > 0x3f3f3f3f / 2) puts(\"impossible\"); else printf(\"%d\\n\", dist[n]); return 0; } Spfa \u7b97\u6cd5 \u9898\u89e3 \u662f\u57fa\u4e8ebellman_ford \u7b97\u6cd5\u7684\u4e00\u79cd\u4f18\u5316 \u56e0\u4e3abellman \u7b97\u6cd5\u662f\u5bf9\u6240\u6709\u7684\u8fb9\u90fd\u8fdb\u884c\u4e86\u53d6\u6700\u77ed\u8ddd\u79bb \u800c Spfa \u7b97\u6cd5\u5219\u662f\u5229\u7528 \u961f\u5217 \u6765\u5b58\u50a8\u6bcf\u6b21\u53d6\u5f97\u5230\u7684 \u6700\u77ed\u8ddd\u79bb \u5e76\u7528\u8fd9\u4e2a \u8ddd\u79bb \u6765\u66f4\u65b0\u522b\u7684\u8ddd\u79bb bellman \u7b97\u6cd5 \u4fdd\u7559\u4e86\u6240\u6709\u5230\u8fd9\u4e2a\u70b9\u7684\u524d\u4e00\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u4f46\u8fd9\u6837\u7684\u8bdd \u65e0\u7591\u4f1a\u6709\u4e00\u4e9b\u8fb9\u662f\u672a\u66fe\u7528\u8fc7\u7684 \u800c spfa \u7b97\u6cd5\u5c31\u662f\u53ea\u8bb0\u5f55\u4e86\u4f1a\u88ab\u66f4\u65b0\u7684\u8282\u70b9 \u5e76 \u7528\u8fd9\u4e2a\u70b9\u6765\u66f4\u65b0\u522b\u7684\u70b9 \u7528 for \u5faa\u73af \u6765\u904d\u5386\u6240\u6709\u4e0e\u5f53\u524d\u70b9\u6709\u63a5\u89e6\u7684\u6240\u6709\u70b9 \u7136\u540e\u7528\u961f\u5217\u5c06\u8be5\u70b9\u5b58\u4e0b\u6765 \u5728\u6bcf\u6b21\u904d\u5386\u961f\u5217\u4e2d\u7684\u70b9 \u4ee5\u6b64\u4e3a\u5ef6\u7eed\u4e0d\u65ad\u8fde\u63a5\u6240\u6709\u53ef\u80fd\u4f1a\u9047\u5230\u7684\u70b9 \u5373\u8be5\u70b9\u7528\u5230\u4e86 \u5c31\u4f1a \u7ee7\u7eed\u66f4\u65b0\u5b83\u540e\u9762\u7684\u70b9 Bellman_ford\u7b97\u6cd5\u4f1a\u904d\u5386\u6240\u6709\u7684\u8fb9\uff0c\u4f46\u662f\u6709\u5f88\u591a\u7684\u8fb9\u904d\u5386\u4e86\u5176\u5b9e\u6ca1\u6709\u4ec0\u4e48\u610f\u4e49\uff0c\u6211\u4eec\u53ea\u7528\u904d\u5386\u90a3\u4e9b\u5230\u6e90\u70b9\u8ddd\u79bb\u53d8\u5c0f\u7684\u70b9\u6240\u8fde\u63a5\u7684\u8fb9\u5373\u53ef\uff0c\u53ea\u6709\u5f53\u4e00\u4e2a\u70b9\u7684\u524d\u9a71\u7ed3\u70b9\u66f4\u65b0\u4e86\uff0c\u8be5\u8282\u70b9\u624d\u4f1a\u5f97\u5230\u66f4\u65b0\uff1b\u56e0\u6b64\u8003\u8651\u5230\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u5c06\u521b\u5efa\u4e00\u4e2a\u961f\u5217\u6bcf\u4e00\u6b21\u52a0\u5165\u8ddd\u79bb\u88ab\u66f4\u65b0\u7684\u7ed3\u70b9\u3002 \u5173\u4e8e\u4e3a\u4ec0\u4e48 \u6bcf\u6b21\u53ea\u4f1a\u8bb2\u4fee\u6539\u8fc7\u7684\u8fb9\u52a0\u5165\u8fdb\u53bb #include <iostream> #include <algorithm> #include <cstring> #include <queue> using namespace std; const int N = 1e5 +10; int h[N],w[N],e[N],ne[N],idx; int dist[N]; bool st[N]; void add(int a,int b,int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } void spfa() { memset(dist,0x3f,sizeof dist); dist[1] = 0; queue<int>q; q.push(1); st[1] = true; while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t] ; i != -1 ; i = ne[i]) { int j = e[i]; if(dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if(!st[j]) // \u8fd9\u91cc\u53ea\u4f1a\u5b58\u653e\u5df2\u7ecf\u88ab\u66f4\u65b0\u8fc7\u7684\u8fb9 \uff0c\uff0c \u5982\u679c\u88ab\u66f4\u65b0\u4e86 \u4e14\u4e0d\u518d\u961f\u5217\u4e2d\u624d\u4f1a\u88ab\u7ee7\u7eed\u6dfb\u52a0 { q.push(j); st[j] = true; } } } } } int main(void) { int n,m; cin >> n >> m; memset(h,-1,sizeof h); while(m --) { int a,b,c; cin >> a>> b >> c; add(a,b,c); } spfa(); if(dist[n] == 0x3f3f3f3f) cout << \"impossible\" << endl; else cout << dist[n] << endl; return 0; } Foyld \u7b97\u6cd5 \u7528 \u90bb\u63a5\u8868\u6765\u5b58\u50a8 \u4f46\u662f \u4e3a\u4ec0\u4e48\u8fd9\u6837 \u521d\u59cb\u5316 \u56e0\u4e3a g \u6570\u7ec4\u4e2d\u5b58\u50a8\u7684\u5c31\u662f\u70b9\u5230\u70b9\u7684\u8ddd\u79bb\uff0c\u6240\u4ee5\u5f53 i == j \u7684\u65f6\u5019 \u8ddd\u79bb\u4e3a 0 \uff0c\u6240\u4ee5\u521d\u59cb\u5316\u4e3a 0\uff1b k i j g[i][j] = min(g[i][j] , g[i][k] + g[k][j]); #include <iostream> #include <algorithm> using namespace std; const int N = 210,INF = 1e9; int g[N][N]; int n,m,q; void Floyd() { for(int k = 1 ;k <= n ;k ++) for(int i = 1 ;i <= n ; i ++) for(int j = 1; j <= n ;j ++) g[i][j] = min(g[i][j] , g[i][k] + g[k][j]); } int main(void) { cin >> n >> m >> q; for(int i = 1; i <= n ; i ++) for(int j = 1; j <= n ; j ++) if(i == j) g[i][j] = 0; else g[i][j] = INF; while(m --) { int a,b,c; cin >> a >> b >> c; g[a][b] = min(g[a][b] , c); } Floyd(); while(q -- ) { int x,y; cin >> x >> y; if(g[x][y] > INF / 2) cout <<\"impossible\" << endl; else cout << g[x][y] << endl; } return 0; } \u6700\u5c0f\u751f\u6210\u6811 Prim \u7b97\u6cd5 \u5904\u7406\u7a20\u5bc6\u56fe \u4e3b\u8981\u662f\u5229\u7528 \u6269\u5927\u96c6\u5408 \u7684\u601d\u60f3\u6765\u505a\u7684 \uff0c\u4e0d\u65ad\u627e\u5230\u8ddd\u79bb\u5f53\u524d\u96c6\u5408\u6700\u8fd1\u7684\u70b9\uff0c\u5e76\u628a\u4ed6\u52a0\u5165 \u4e0e dijkstra \u7b97\u6cd5\u7c7b\u4f3c \u679a\u4e3e n \u6b21 \u627e\u5230\u8ddd\u79bb\u96c6\u5408\u6700\u8fd1\u7684\u70b9 t \u7528 t \u6765\u66f4\u65b0\u5176\u4ed6\u70b9\u5230\u96c6\u5408\u7684\u8ddd\u79bb \u5229\u7528 res \u8bb0\u5f55\u6240\u6709\u4e0d\u662f\u7b2c\u4e00\u6761\u8fb9\u7684\u65f6\u5019\u7684\u6743\u91cd\u548c \u5f53\u51fa\u73b0\u4e0d\u662f\u7b2c\u4e00\u6761\u8fb9\u5e76\u4e14\u6700\u8fd1\u8ddd\u79bb\u4e5f\u662f\u8d8b\u8fd1\u4e8e\u6b63\u65e0\u7a77\u65f6\uff0c\u76f4\u63a5\u7ed3\u675f \u8fd4\u56de false \u6700\u540e\u4f7f\u7528 g[t] [j] \u65f6\uff0c\u5173\u4e8e\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b83\u7684\u539f\u56e0\u662f\uff0c\u9700\u8981\u627e\u5230\u5f53\u524d\u70b9\u8ddd\u79bb\u96c6\u5408\u6700\u8fd1\u7684\u70b9\uff0c\u53c8\u56e0\u4e3a dist \u672c\u8eab\u4fdd\u5b58\u7684\u5c31\u662f\u5f53\u524d\u70b9\u5230\u7b2c\u4e00\u4e2a\u70b9\u5373\u96c6\u5408\u7684\u8ddd\u79bb\uff0c\u518d\u52a0\u4e0a\u524d\u9762\u6bcf\u6b21\u5faa\u73af\u627e\u5230\u7684\u90fd\u662f\u8ddd\u79bb\u4e0a\u4e00\u4e2a\u70b9\u7684\u6700\u8fd1\u8ddd\u79bb\uff0c\u6240\u4ee5\u8bf4 \u5f53 dist \u4e0d\u662f\u6700\u8fd1\u7684\u8ddd\u79bb\u65f6 \u6700\u8fd1\u7684\u8ddd\u79bb\u5c31\u662f g \uff0c\uff0c\u56e0\u4e3a\u4e0a\u9762\u6bcf\u6b21\u7684\u90fd\u662f\u53d6\u5230\u4e86\u8ddd\u79bb\u7684\u6700\u5c0f\u503c #include <iostream> #include <algorithm> #include <cstring> using namespace std; const int N = 550,INF = 0x3f3f3f3f; const int M = 1e5+10; int g[N][N]; bool st[N]; int dist[N]; int res; int n,m; int Prim() { memset(dist,0x3f,sizeof dist); int res = 0 ; for(int i = 0 ; i < n ; i ++) { int t = -1; for(int j = 1; j <= n ; j++) { if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j; } if(i && dist[t] == INF) return INF; if(i) res += dist[t]; for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]); // \u8bb0\u5f55\u5230\u96c6\u5408\u7684\u8ddd\u79bb\uff0c\u800c\u4e0d\u662f\u8ddf\u6700\u77ed\u8def\u4e00\u6837\u5230\u8d77\u70b9\u7684\u8ddd\u79bb st[t] = true; } return res; } int main(void) { cin >> n >> m; memset(g,0x3f,sizeof g); while(m--) { int a,b,c; cin >> a>> b >> c; g[a][b] = g[b][a] = min(g[a][b],c); } int res = Prim(); if(res == 0x3f3f3f3f) cout << \"impossible\" << endl; else cout << res << endl; return 0; } Kruskal \u7b97\u6cd5 \u5904\u7406\u7a00\u758f\u56fe \u901a\u8fc7\u7ed3\u6784\u4f53**\u6309\u7167\u6743\u91cd\u6765\u8fdb\u884c\u6392\u5e8f ** \u6392\u5e8f\u4fdd\u8bc1\u662f\u6700\u5c0f\u751f\u6210\u6811 \u5229\u7528\u5e76\u67e5\u96c6\u548c\u7ed3\u6784\u4f53\u6765\u5b58\u50a8\u8fb9\u548c\u6743\u91cd \u6bcf\u6b21\u5982\u679c\u4e24\u70b9\u4e4b\u95f4\u6ca1\u6709\u8054\u7cfb\u5219\u5229\u7528\u5e76\u67e5\u96c6 \u8fdb\u884c \u4e24\u4e24 \u76f8\u52a0 \u8bb0\u5f55\u6743\u91cd\u548c count \u5982\u679c cnt < n-1 \u5219\u4e0d\u5b58\u5728\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5426\u5219\u8f93\u51fa\u6743\u503c #include < iostream> #include <algorithm> using namespace std; const int N = 1e5 +10 , M = 200010; const int INF = 0x3f3f3f3f; int p[N]; int n,m; struct Edges { int a,b,w; bool operator < (const Edges & W)const { return w < W.w; } }edges[M]; int find(int x) { if(x != p[x]) p[x] = find(p[x]); else return p[x]; } int kruskal() { int cnt = 0 , res = 0; sort(edges,edges + m); for(int i = 1; i <= n ; i ++) p[i] = i; for(int i = 0 ; i < m ; i ++) { int a = edges[i].a , b = edges[i].b , w = edges[i].w; a = find(a),b = find(b); if(a != b) { p[a] = b; res += w; cnt ++; } } if(cnt < n-1) return INF; return res; } int main(void) { cin >> n >> m; for(int i = 0 ;i < m ; i ++) { int a,b,c; cin >> a >> b >> c; edges[i] = {a,b,c}; } int t = kruskal(); if(t == INF) cout <<\"impossible\" << endl; else cout << t <<endl; return 0; } \u4e8c\u5206\u56fe **\u5308\u7259\u5229\u7b97\u6cd5 ** \u5224\u65ad\u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d \u6839\u672c\u539f\u7406 \u662f\u904d\u5386\u6bcf\u4e00\u4e2a\u70b9 \u7136\u540e \u53bb\u627e\u5230\u8be5\u70b9\u6307\u5411\u7684\u70b9\uff0c\u518d\u8ddf\u7740\u5224\u65ad \u8be5\u70b9\u662f\u5426\u5df2\u7ecf\u88ab\u522b\u7684\u70b9\u6240\u5339\u914d\u6216\u662f \u88ab\u522b\u7684\u70b9\u5339\u914d\u7684\u90a3\u4e2a\u70b9 \u662f\u5426\u53ef\u4ee5\u5339\u914d\u522b\u7684\u70b9 \u5982\u679c \u53ef\u4ee5 \u5c31\u4f1a\u66ff\u4ee3\u4e0a\u4e00\u4e2a\u5339\u914d\u7684\u70b9 \u5c31\u662f\u4e00\u4e2a\u9012\u5f52\u7684\u8fc7\u7a0b \u4e3b\u8981\u5c31\u662f match \u6570\u7ec4 \u548c st \u6570\u7ec4 for \u5faa\u73af\u91cc\u9762\u6bcf\u6b21\u90fd\u4f1a\u521d\u59cb\u5316\u6240\u6709\u7684\u4e3a false \u539f\u56e0\u662f \u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4f1a\u8fdb\u884c\u5b8c\u7f8e\u7684\u9012\u5f52 \u4fdd\u8bc1\u4e86 \u6700\u4f73\u7b54\u6848\u7684\u51fa\u73b0\uff08\u628a\u6240\u6709\u59b9\u5b50\u6e05\u7a7a\uff09\u5373\u521d\u59cb\u5316 #include <iostream> #include <cstring> using namespace std; const int N = 550,M = 100010; int n1,n2,m; bool st[N]; int h[N],e[M],ne[M]; int idx; int match[N]; void add(int a,int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx++; } bool find(int x) { for(int i = h[x]; i != -1 ; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } int main(void) { cin >> n1 >> n2 >> m; memset(h,-1,sizeof h); while(m--) { int a,b; cin >> a >> b; add(a,b); } int res = 0; for(int i = 1;i<=n1;i++) { memset(st,false,sizeof st); if(find(i)) res ++; } cout << res << endl; return 0; } \u67d3\u8272\u6cd5\u5224\u65ad \u662f\u5426\u4e3a\u4e8c\u5206\u56fe \u5229\u7528\u67d3\u8272 1\uff0c2 \u6765\u7ed9\u70b9\u505a\u4e0a\u6807\u8bb0\uff0c\u5e76\u5229\u7528 dfs \u7684\u8fc7\u7a0b\u6765\u8fdb\u884c\u6df1\u5ea6\u7684\u5224\u65ad \u5982\u679c bool \u7c7b\u578b\u7684 dfs \u8fd4\u56de false \u7684\u8bdd\uff0c\u4ee3\u8868\u67d3\u8272\u5931\u8d25\uff0c\u5373\u5b58\u5728\u51b2\u7a81\uff0c\u4e0d\u6ee1\u8db3\u4e8c\u5206\u56fe\u7684\u6027\u8d28 \u5982\u679c\u5f53\u524d\u70b9\u6ca1\u6709\u67d3\u8272\uff0c\u5c31\u5229\u7528 dfs \u628a\u4ed6\u67d3\u6210 3 - x \u8272\uff0c\u5982\u679c\u6709\u989c\u8272 \u5e76\u4e14\u76f8\u7b49\u7684\u8bdd \u76f4\u63a5\u8fd4\u56de false #include <iostream> #include <algorithm> #include <cstring> using namespace std; const int N = 1e5 + 10,M = 200010; int h[N],e[M],ne[M],idx; int color[N]; int n,m; void add(int a,int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } bool dfs(int u,int x) { color[u] = x; for(int i = h[u] ; i != -1 ; i = ne[i]) { int j = e[i]; if(!color[j]) { if(!dfs(j,3-x)) return false; } else if(color[j] == x) return false; } return true; } int main(void) { cin >> n >> m ; memset(h, -1, sizeof h); while(m --) { int a,b; cin >> a >> b; add(a,b),add(b,a); } bool flag = true; for(int i = 1 ;i <= n ; i ++) { if(!color[i]) { if(!dfs(i,1)) { flag = false; break; } } } if(flag) cout << \"Yes\" << endl; else cout << \"No\" << endl; return 0; } Topsort Dfs Bfs topsort \u62d3\u6251\u6392\u5e8f \u5229\u7528\u5165\u5ea6\u6765\u8fdb\u884c\u5224\u65ad \u627e\u5230\u6240\u6709\u5165\u5ea6\u4e3a 0 \u7684\u70b9\u628a\u5176\u52a0\u5165\u961f\u5217\u4e2d \u6700\u597d\u5229\u7528\u624b\u52a8\u6a21\u62df\u961f\u5217 \u8fd9\u6837\u4f1a\u5bf9\u7ed3\u679c\u7684\u8f93\u51fa\u8d77\u5230\u7b80\u5316\u4f5c\u7528 \u5728\u5faa\u73af\u4e2d\uff0c\u5982\u679c\u5b58\u5728\u5165\u5ea6\u4e3a 1 \u7684\u60c5\u51b5\u51fa\u73b0\u65f6\uff0c\u4e5f\u4f1a\u628a\u8be5\u503c\u52a0\u5165\u5230\u961f\u5217\u4e2d\uff0c\u56e0\u4e3a\u4ed6\u540c\u6837\u53ef\u4ee5\u6ee1\u8db3\u62d3\u6251\u7684\u6761\u4ef6 Dfs \u6df1\u5ea6\u4f18\u5148\u904d\u5386 dfs \u4e3b\u8981\u662f\u4e00\u4e2a\u5229\u7528\u9012\u5f52\u7684\u8fc7\u7a0b \u6df1\u5ea6\u4f18\u5148\u904d\u5386 \u53ef\u4ee5\u5904\u7406\u6392\u5217\u6570\u5b57\u7b49\u95ee\u9898 Bfs \u5bbd\u5ea6\u4f18\u5148\u904d\u5386 \u5bbd\u5ea6\u4f18\u5148\u904d\u5386 bfs \u4e3b\u8981\u5229\u7528\u961f\u5217\u6765\u8fdb\u884c\u5b58\u50a8\uff0c\u5f53\u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e0d\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u4f1a\u4e00\u76f4\u7ee7\u7eed\u4e0b\u53bb\uff0c\u6bcf\u6b21\u63a8\u5165\u6ee1\u8db3\u6761\u4ef6\u7684\u70b9\uff0c\u6700\u540e\u627e\u5230\u6700\u77ed\u7684\u8def\u5f84\u6216\u8005\u662f\u8ff7\u5bab\u7684\u51fa\u8def","title":"Graph"},{"location":"algorithm/graph/#_1","text":"","title":"\u56fe\u8bba\u7b97\u6cd5"},{"location":"algorithm/graph/#_2","text":"\u80fd\u7528dijkstra\u7684\u5c31\u522b\u7528spfa","title":"\u6700\u77ed\u8def"},{"location":"algorithm/graph/#dijkstra","text":"\u9898\u89e3 \u6734\u7d20\u7528\u90bb\u63a5\u77e9\u9635\u5b58\u50a8 // \u7a20\u5bc6\u56fe \u70b9\u5c11\u7ebf\u591a 1.\u5faa\u73af n \u6b21 2.\u627e\u5230\u4e00\u4e2a t \u7528\u6765\u4ee3\u8868\u5f53\u524d\u6240\u6709\u70b9\u5230\u76ee\u524d\u70b9\u7684\u6700\u77ed\u8ddd\u79bb 3.\u7528 t \u6765\u66f4\u65b0\u5230\u8fd9\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb #include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 550; int g[N][N]; int dist[N]; bool st[N]; int n,m; void dijkstra() { memset(dist,0x3f,sizeof dist); dist[1] = 0; for(int i = 0 ; i < n; i ++) { int t = -1; for(int j = 1; j <= n ; j ++) if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j ; for(int j = 1 ;j <= n ; j ++) dist[j] = min(dist[j],dist[t] + g[t][j]); st[t] = true; } } int main(void) { memset(g,0x3f,sizeof g); cin >> n >> m ; while(m --) { int a,b,c; cin >> a >> b >> c; g[a][b] = min(g[a][b],c); } dijkstra(); if(dist[n] == 0x3f3f3f3f) cout << -1 << endl; else cout << dist[n] << endl; return 0; }","title":"Dijkstra \u7b97\u6cd5"},{"location":"algorithm/graph/#dijkstr","text":"\u7a00\u758f\u56fe \u7528\u90bb\u63a5\u77e9\u9635\u6765\u5b58\u50a8 \u7528\u5806\u8fdb\u884c\u4f18\u5316 \u6bcf\u6b21\u53d6\u6700\u77ed\u503c\u7684\u65f6\u5019 \u53d6\u5806\u9876\u5143\u7d20 \u76f8\u5f53\u4e8e\u662f\u7701\u7565\u4e86\u6734\u7d20\u7248dijkstra \u7684\u627e\u5230\u8ddd\u79bb\u5f53\u524d\u70b9\u6700\u77ed\u8ddd\u79bb\u8fd9\u4e00\u6b65\uff1b\uff1b \u4ee3\u66ff\u4e0a\u8fb9\u7684\u7b2c\u4e00\u4e8c\u6b65 \u7136\u540e\u66f4\u65b0\u6240\u6709\u5806\u7684\u8ddd\u79bb \u7528\u4e00\u4e2a pair \u6570\u7ec4\u6765\u5b58\u50a8\u5230\u8d77\u70b9\u7684\u8ddd\u79bb\u548c\u5f53\u524d\u70b9\u7684\u7f16\u53f7 \u7528\u90bb\u63a5\u8868\u904d\u5386\u6240\u6709\u5230\u8fbe\u7684\u70b9 \u5e76\u5bf9\u5176\u8fdb\u884c\u5224\u65ad \u5982\u679c\u5c0f\u4e8e \u5e76\u4e14\u8be5\u503c\u5e76\u672a\u88ab\u4f7f\u7528\u8fc7 \u5373 st \u4e3a false \u53ef\u4ee5\u8fdb\u884c\u66f4\u65b0 \u5c31\u628a\u8be5\u503c\u548c\u8ddd\u79bb\u63a8\u8fdb heap \u6570\u7ec4\u4e2d \u8fd9\u91cc \u4e0e spfa \u7b97\u6cd5\u8fdb\u884c\u4e2a\u533a\u5206 dijsktra \u7b97\u6cd5\u4e00\u822c\u5728\u53d6\u5f97\u7f16\u53f7\u540e\u5c31\u8fdb\u884c\u5224\u65ad \u662f\u5426\u8fdb\u884c continue \u73af\u8282 spfa \u7b97\u6cd5 \u5219\u5728 for \u5faa\u73af\u548c if \u5faa\u73af \u4e4b\u540e\u5224\u65ad\u8be5\u503c\u662f\u5426\u4f7f\u7528\u8fc7 dijkstra\u4fdd\u8bc1\u4e86\u6bcf\u4e2a\u70b9\u53ea\u4f1a\u88ab\u4f7f\u7528\u4e00\u6b21\uff0c\u800cspfa\u5219\u4e00\u4e2a\u70b9\u53ef\u80fd\u88ab\u591a\u6b21\u4f7f\u7528 \u200b SPFA\u53ef\u4ee5\u5904\u7406\u8d1f\u6743\u8fb9\uff0c\u4f46\u662f\u4e0d\u80fd\u5904\u7406\u6709\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff1b\u800cDijkstra\u4e0d\u80fd\u5904\u7406\u5e26\u6709\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff0c\u56e0\u4e3aDijkstra\u7b97\u6cd5\u5728\u8ba1\u7b97\u6700\u77ed\u8def\u5f84\u65f6\uff0c\u4e0d\u4f1a\u56e0\u4e3a\u8d1f\u8fb9\u7684\u51fa\u73b0\u800c\u66f4\u65b0\u5df2\u7ecf\u8ba1\u7b97\u8fc7(\u6536\u5f55\u8fc7)\u7684\u9876\u70b9\u7684\u8def\u5f84\u957f\u5ea6\uff1b \u200b \u603b\u7ed3\u4e00\u4e0b\uff1aBellman-ford\u53ef\u4ee5\u5904\u7406\u4efb\u610f\u5e26\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u73af\u7684\u56fe\uff0cSPFA\u53ef\u4ee5\u5904\u7406\u5e26\u8d1f\u6743\u8fb9\u7684\u56fe\uff0cDijkstra\u53ea\u80fd\u5904\u7406\u5e26\u6b63\u6743\u8fb9\u7684\u56fe\uff1b\u5f53\u7136\uff0c\u4ece\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u6548\u7387\u6765\u8bb2\uff0c\u662f\u53cd\u8fc7\u6765\u7684\uff0chh #include <iostream> #include <algorithm> #include <queue> #include <cstring> using namespace std; typedef pair<int,int> PII; const int N = 1e6 + 10; int h[N],e[N],ne[N],w[N],idx; int dist[N]; bool st[N]; int n,m; void add(int a,int b,int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++; } void dijkstra() { memset(dist,0x3f,sizeof dist); priority_queue <PII,vector<PII>,greater<PII> >heap; dist[1] = 0; heap.push({0,1}); while(heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second; int s = t.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1 ; i = ne[i]) { int j = e[i]; if(dist[j] > dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j],j}); } } } } int main(void) { cin >> n >> m ; memset(h,-1,sizeof h); while(m--) { int a,b,c; cin >> a >> b >> c ; add(a,b,c); } dijkstra(); if(dist[n] == 0x3f3f3f3f) cout << -1 << endl; else cout << dist[n] << endl; return 0; }","title":"\u4f18\u5316\u7248\u7684dijkstr \u7b97\u6cd5"},{"location":"algorithm/graph/#bellman_ford","text":"\u7528\u4e8e\u5904\u7406\u5b58\u5728\u8d1f\u6743\u8fb9\u7684\u73af\u8282 \u5e76\u4e14\u5b58\u5728 \u5224\u65ad\u81f3\u5c11\u5728\u51e0\u6761\u8fb9\u5b9e\u73b0 \u5229\u7528\u7ed3\u6784\u4f53\u6765\u5b58\u50a8 \u7b2c\u4e00\u5c42 for \u5faa\u73af\u4ee3\u8868\u6700\u77ed\u51e0\u6761\u8fb9 \u63a5\u4e0b\u6765\u5bf9\u6240\u6709\u7684\u8fb9\u8fdb\u884c\u904d\u5386\uff0c\u7528 struct \u6765\u5bf9\u6bcf\u6761\u8fb9\u53d6\u6700\u77ed\u7684\u8def\u5f84 \u4e3a\u4e86\u907f\u514d\u51fa \u884c\u6bd4\u5bf9 #include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 550,M = 10010; struct Edge { int a,b,c; }edges[M]; int n,m,k; int dist[N]; int last[N]; void bellman_ford() { memset(dist,0x3f,sizeof dist); dist[1] = 0; for(int i = 0 ; i < k ;i ++) { memcpy(last,dist,sizeof dist); for(int j = 0 ; j< m ; j ++) { auto e = edges[j]; dist[e.b] = min(dist[e.b], last[e.a] + e.c); } } } int main(void) { cin >> n >> m >> k; for(int i = 0;i<m;i++) { int x,y,z; cin >> x >> y >> z; edges[i] = {x,y,z}; } bellman_ford(); if (dist[n] > 0x3f3f3f3f / 2) puts(\"impossible\"); else printf(\"%d\\n\", dist[n]); return 0; }","title":"Bellman_ford \u7b97\u6cd5"},{"location":"algorithm/graph/#spfa","text":"\u9898\u89e3 \u662f\u57fa\u4e8ebellman_ford \u7b97\u6cd5\u7684\u4e00\u79cd\u4f18\u5316 \u56e0\u4e3abellman \u7b97\u6cd5\u662f\u5bf9\u6240\u6709\u7684\u8fb9\u90fd\u8fdb\u884c\u4e86\u53d6\u6700\u77ed\u8ddd\u79bb \u800c Spfa \u7b97\u6cd5\u5219\u662f\u5229\u7528 \u961f\u5217 \u6765\u5b58\u50a8\u6bcf\u6b21\u53d6\u5f97\u5230\u7684 \u6700\u77ed\u8ddd\u79bb \u5e76\u7528\u8fd9\u4e2a \u8ddd\u79bb \u6765\u66f4\u65b0\u522b\u7684\u8ddd\u79bb bellman \u7b97\u6cd5 \u4fdd\u7559\u4e86\u6240\u6709\u5230\u8fd9\u4e2a\u70b9\u7684\u524d\u4e00\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u4f46\u8fd9\u6837\u7684\u8bdd \u65e0\u7591\u4f1a\u6709\u4e00\u4e9b\u8fb9\u662f\u672a\u66fe\u7528\u8fc7\u7684 \u800c spfa \u7b97\u6cd5\u5c31\u662f\u53ea\u8bb0\u5f55\u4e86\u4f1a\u88ab\u66f4\u65b0\u7684\u8282\u70b9 \u5e76 \u7528\u8fd9\u4e2a\u70b9\u6765\u66f4\u65b0\u522b\u7684\u70b9 \u7528 for \u5faa\u73af \u6765\u904d\u5386\u6240\u6709\u4e0e\u5f53\u524d\u70b9\u6709\u63a5\u89e6\u7684\u6240\u6709\u70b9 \u7136\u540e\u7528\u961f\u5217\u5c06\u8be5\u70b9\u5b58\u4e0b\u6765 \u5728\u6bcf\u6b21\u904d\u5386\u961f\u5217\u4e2d\u7684\u70b9 \u4ee5\u6b64\u4e3a\u5ef6\u7eed\u4e0d\u65ad\u8fde\u63a5\u6240\u6709\u53ef\u80fd\u4f1a\u9047\u5230\u7684\u70b9 \u5373\u8be5\u70b9\u7528\u5230\u4e86 \u5c31\u4f1a \u7ee7\u7eed\u66f4\u65b0\u5b83\u540e\u9762\u7684\u70b9 Bellman_ford\u7b97\u6cd5\u4f1a\u904d\u5386\u6240\u6709\u7684\u8fb9\uff0c\u4f46\u662f\u6709\u5f88\u591a\u7684\u8fb9\u904d\u5386\u4e86\u5176\u5b9e\u6ca1\u6709\u4ec0\u4e48\u610f\u4e49\uff0c\u6211\u4eec\u53ea\u7528\u904d\u5386\u90a3\u4e9b\u5230\u6e90\u70b9\u8ddd\u79bb\u53d8\u5c0f\u7684\u70b9\u6240\u8fde\u63a5\u7684\u8fb9\u5373\u53ef\uff0c\u53ea\u6709\u5f53\u4e00\u4e2a\u70b9\u7684\u524d\u9a71\u7ed3\u70b9\u66f4\u65b0\u4e86\uff0c\u8be5\u8282\u70b9\u624d\u4f1a\u5f97\u5230\u66f4\u65b0\uff1b\u56e0\u6b64\u8003\u8651\u5230\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u5c06\u521b\u5efa\u4e00\u4e2a\u961f\u5217\u6bcf\u4e00\u6b21\u52a0\u5165\u8ddd\u79bb\u88ab\u66f4\u65b0\u7684\u7ed3\u70b9\u3002 \u5173\u4e8e\u4e3a\u4ec0\u4e48 \u6bcf\u6b21\u53ea\u4f1a\u8bb2\u4fee\u6539\u8fc7\u7684\u8fb9\u52a0\u5165\u8fdb\u53bb #include <iostream> #include <algorithm> #include <cstring> #include <queue> using namespace std; const int N = 1e5 +10; int h[N],w[N],e[N],ne[N],idx; int dist[N]; bool st[N]; void add(int a,int b,int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } void spfa() { memset(dist,0x3f,sizeof dist); dist[1] = 0; queue<int>q; q.push(1); st[1] = true; while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t] ; i != -1 ; i = ne[i]) { int j = e[i]; if(dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if(!st[j]) // \u8fd9\u91cc\u53ea\u4f1a\u5b58\u653e\u5df2\u7ecf\u88ab\u66f4\u65b0\u8fc7\u7684\u8fb9 \uff0c\uff0c \u5982\u679c\u88ab\u66f4\u65b0\u4e86 \u4e14\u4e0d\u518d\u961f\u5217\u4e2d\u624d\u4f1a\u88ab\u7ee7\u7eed\u6dfb\u52a0 { q.push(j); st[j] = true; } } } } } int main(void) { int n,m; cin >> n >> m; memset(h,-1,sizeof h); while(m --) { int a,b,c; cin >> a>> b >> c; add(a,b,c); } spfa(); if(dist[n] == 0x3f3f3f3f) cout << \"impossible\" << endl; else cout << dist[n] << endl; return 0; }","title":"Spfa \u7b97\u6cd5"},{"location":"algorithm/graph/#foyld","text":"\u7528 \u90bb\u63a5\u8868\u6765\u5b58\u50a8 \u4f46\u662f \u4e3a\u4ec0\u4e48\u8fd9\u6837 \u521d\u59cb\u5316 \u56e0\u4e3a g \u6570\u7ec4\u4e2d\u5b58\u50a8\u7684\u5c31\u662f\u70b9\u5230\u70b9\u7684\u8ddd\u79bb\uff0c\u6240\u4ee5\u5f53 i == j \u7684\u65f6\u5019 \u8ddd\u79bb\u4e3a 0 \uff0c\u6240\u4ee5\u521d\u59cb\u5316\u4e3a 0\uff1b k i j g[i][j] = min(g[i][j] , g[i][k] + g[k][j]); #include <iostream> #include <algorithm> using namespace std; const int N = 210,INF = 1e9; int g[N][N]; int n,m,q; void Floyd() { for(int k = 1 ;k <= n ;k ++) for(int i = 1 ;i <= n ; i ++) for(int j = 1; j <= n ;j ++) g[i][j] = min(g[i][j] , g[i][k] + g[k][j]); } int main(void) { cin >> n >> m >> q; for(int i = 1; i <= n ; i ++) for(int j = 1; j <= n ; j ++) if(i == j) g[i][j] = 0; else g[i][j] = INF; while(m --) { int a,b,c; cin >> a >> b >> c; g[a][b] = min(g[a][b] , c); } Floyd(); while(q -- ) { int x,y; cin >> x >> y; if(g[x][y] > INF / 2) cout <<\"impossible\" << endl; else cout << g[x][y] << endl; } return 0; }","title":"Foyld \u7b97\u6cd5"},{"location":"algorithm/graph/#_3","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"algorithm/graph/#prim","text":"\u5904\u7406\u7a20\u5bc6\u56fe \u4e3b\u8981\u662f\u5229\u7528 \u6269\u5927\u96c6\u5408 \u7684\u601d\u60f3\u6765\u505a\u7684 \uff0c\u4e0d\u65ad\u627e\u5230\u8ddd\u79bb\u5f53\u524d\u96c6\u5408\u6700\u8fd1\u7684\u70b9\uff0c\u5e76\u628a\u4ed6\u52a0\u5165 \u4e0e dijkstra \u7b97\u6cd5\u7c7b\u4f3c \u679a\u4e3e n \u6b21 \u627e\u5230\u8ddd\u79bb\u96c6\u5408\u6700\u8fd1\u7684\u70b9 t \u7528 t \u6765\u66f4\u65b0\u5176\u4ed6\u70b9\u5230\u96c6\u5408\u7684\u8ddd\u79bb \u5229\u7528 res \u8bb0\u5f55\u6240\u6709\u4e0d\u662f\u7b2c\u4e00\u6761\u8fb9\u7684\u65f6\u5019\u7684\u6743\u91cd\u548c \u5f53\u51fa\u73b0\u4e0d\u662f\u7b2c\u4e00\u6761\u8fb9\u5e76\u4e14\u6700\u8fd1\u8ddd\u79bb\u4e5f\u662f\u8d8b\u8fd1\u4e8e\u6b63\u65e0\u7a77\u65f6\uff0c\u76f4\u63a5\u7ed3\u675f \u8fd4\u56de false \u6700\u540e\u4f7f\u7528 g[t] [j] \u65f6\uff0c\u5173\u4e8e\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b83\u7684\u539f\u56e0\u662f\uff0c\u9700\u8981\u627e\u5230\u5f53\u524d\u70b9\u8ddd\u79bb\u96c6\u5408\u6700\u8fd1\u7684\u70b9\uff0c\u53c8\u56e0\u4e3a dist \u672c\u8eab\u4fdd\u5b58\u7684\u5c31\u662f\u5f53\u524d\u70b9\u5230\u7b2c\u4e00\u4e2a\u70b9\u5373\u96c6\u5408\u7684\u8ddd\u79bb\uff0c\u518d\u52a0\u4e0a\u524d\u9762\u6bcf\u6b21\u5faa\u73af\u627e\u5230\u7684\u90fd\u662f\u8ddd\u79bb\u4e0a\u4e00\u4e2a\u70b9\u7684\u6700\u8fd1\u8ddd\u79bb\uff0c\u6240\u4ee5\u8bf4 \u5f53 dist \u4e0d\u662f\u6700\u8fd1\u7684\u8ddd\u79bb\u65f6 \u6700\u8fd1\u7684\u8ddd\u79bb\u5c31\u662f g \uff0c\uff0c\u56e0\u4e3a\u4e0a\u9762\u6bcf\u6b21\u7684\u90fd\u662f\u53d6\u5230\u4e86\u8ddd\u79bb\u7684\u6700\u5c0f\u503c #include <iostream> #include <algorithm> #include <cstring> using namespace std; const int N = 550,INF = 0x3f3f3f3f; const int M = 1e5+10; int g[N][N]; bool st[N]; int dist[N]; int res; int n,m; int Prim() { memset(dist,0x3f,sizeof dist); int res = 0 ; for(int i = 0 ; i < n ; i ++) { int t = -1; for(int j = 1; j <= n ; j++) { if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j; } if(i && dist[t] == INF) return INF; if(i) res += dist[t]; for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]); // \u8bb0\u5f55\u5230\u96c6\u5408\u7684\u8ddd\u79bb\uff0c\u800c\u4e0d\u662f\u8ddf\u6700\u77ed\u8def\u4e00\u6837\u5230\u8d77\u70b9\u7684\u8ddd\u79bb st[t] = true; } return res; } int main(void) { cin >> n >> m; memset(g,0x3f,sizeof g); while(m--) { int a,b,c; cin >> a>> b >> c; g[a][b] = g[b][a] = min(g[a][b],c); } int res = Prim(); if(res == 0x3f3f3f3f) cout << \"impossible\" << endl; else cout << res << endl; return 0; }","title":"Prim \u7b97\u6cd5"},{"location":"algorithm/graph/#kruskal","text":"\u5904\u7406\u7a00\u758f\u56fe \u901a\u8fc7\u7ed3\u6784\u4f53**\u6309\u7167\u6743\u91cd\u6765\u8fdb\u884c\u6392\u5e8f ** \u6392\u5e8f\u4fdd\u8bc1\u662f\u6700\u5c0f\u751f\u6210\u6811 \u5229\u7528\u5e76\u67e5\u96c6\u548c\u7ed3\u6784\u4f53\u6765\u5b58\u50a8\u8fb9\u548c\u6743\u91cd \u6bcf\u6b21\u5982\u679c\u4e24\u70b9\u4e4b\u95f4\u6ca1\u6709\u8054\u7cfb\u5219\u5229\u7528\u5e76\u67e5\u96c6 \u8fdb\u884c \u4e24\u4e24 \u76f8\u52a0 \u8bb0\u5f55\u6743\u91cd\u548c count \u5982\u679c cnt < n-1 \u5219\u4e0d\u5b58\u5728\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5426\u5219\u8f93\u51fa\u6743\u503c #include < iostream> #include <algorithm> using namespace std; const int N = 1e5 +10 , M = 200010; const int INF = 0x3f3f3f3f; int p[N]; int n,m; struct Edges { int a,b,w; bool operator < (const Edges & W)const { return w < W.w; } }edges[M]; int find(int x) { if(x != p[x]) p[x] = find(p[x]); else return p[x]; } int kruskal() { int cnt = 0 , res = 0; sort(edges,edges + m); for(int i = 1; i <= n ; i ++) p[i] = i; for(int i = 0 ; i < m ; i ++) { int a = edges[i].a , b = edges[i].b , w = edges[i].w; a = find(a),b = find(b); if(a != b) { p[a] = b; res += w; cnt ++; } } if(cnt < n-1) return INF; return res; } int main(void) { cin >> n >> m; for(int i = 0 ;i < m ; i ++) { int a,b,c; cin >> a >> b >> c; edges[i] = {a,b,c}; } int t = kruskal(); if(t == INF) cout <<\"impossible\" << endl; else cout << t <<endl; return 0; }","title":"Kruskal \u7b97\u6cd5"},{"location":"algorithm/graph/#_4","text":"","title":"\u4e8c\u5206\u56fe"},{"location":"algorithm/graph/#_5","text":"\u5224\u65ad\u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d \u6839\u672c\u539f\u7406 \u662f\u904d\u5386\u6bcf\u4e00\u4e2a\u70b9 \u7136\u540e \u53bb\u627e\u5230\u8be5\u70b9\u6307\u5411\u7684\u70b9\uff0c\u518d\u8ddf\u7740\u5224\u65ad \u8be5\u70b9\u662f\u5426\u5df2\u7ecf\u88ab\u522b\u7684\u70b9\u6240\u5339\u914d\u6216\u662f \u88ab\u522b\u7684\u70b9\u5339\u914d\u7684\u90a3\u4e2a\u70b9 \u662f\u5426\u53ef\u4ee5\u5339\u914d\u522b\u7684\u70b9 \u5982\u679c \u53ef\u4ee5 \u5c31\u4f1a\u66ff\u4ee3\u4e0a\u4e00\u4e2a\u5339\u914d\u7684\u70b9 \u5c31\u662f\u4e00\u4e2a\u9012\u5f52\u7684\u8fc7\u7a0b \u4e3b\u8981\u5c31\u662f match \u6570\u7ec4 \u548c st \u6570\u7ec4 for \u5faa\u73af\u91cc\u9762\u6bcf\u6b21\u90fd\u4f1a\u521d\u59cb\u5316\u6240\u6709\u7684\u4e3a false \u539f\u56e0\u662f \u8ba9\u6bcf\u4e2a\u4eba\u90fd\u4f1a\u8fdb\u884c\u5b8c\u7f8e\u7684\u9012\u5f52 \u4fdd\u8bc1\u4e86 \u6700\u4f73\u7b54\u6848\u7684\u51fa\u73b0\uff08\u628a\u6240\u6709\u59b9\u5b50\u6e05\u7a7a\uff09\u5373\u521d\u59cb\u5316 #include <iostream> #include <cstring> using namespace std; const int N = 550,M = 100010; int n1,n2,m; bool st[N]; int h[N],e[M],ne[M]; int idx; int match[N]; void add(int a,int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx++; } bool find(int x) { for(int i = h[x]; i != -1 ; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } int main(void) { cin >> n1 >> n2 >> m; memset(h,-1,sizeof h); while(m--) { int a,b; cin >> a >> b; add(a,b); } int res = 0; for(int i = 1;i<=n1;i++) { memset(st,false,sizeof st); if(find(i)) res ++; } cout << res << endl; return 0; }","title":"**\u5308\u7259\u5229\u7b97\u6cd5 **"},{"location":"algorithm/graph/#_6","text":"\u662f\u5426\u4e3a\u4e8c\u5206\u56fe \u5229\u7528\u67d3\u8272 1\uff0c2 \u6765\u7ed9\u70b9\u505a\u4e0a\u6807\u8bb0\uff0c\u5e76\u5229\u7528 dfs \u7684\u8fc7\u7a0b\u6765\u8fdb\u884c\u6df1\u5ea6\u7684\u5224\u65ad \u5982\u679c bool \u7c7b\u578b\u7684 dfs \u8fd4\u56de false \u7684\u8bdd\uff0c\u4ee3\u8868\u67d3\u8272\u5931\u8d25\uff0c\u5373\u5b58\u5728\u51b2\u7a81\uff0c\u4e0d\u6ee1\u8db3\u4e8c\u5206\u56fe\u7684\u6027\u8d28 \u5982\u679c\u5f53\u524d\u70b9\u6ca1\u6709\u67d3\u8272\uff0c\u5c31\u5229\u7528 dfs \u628a\u4ed6\u67d3\u6210 3 - x \u8272\uff0c\u5982\u679c\u6709\u989c\u8272 \u5e76\u4e14\u76f8\u7b49\u7684\u8bdd \u76f4\u63a5\u8fd4\u56de false #include <iostream> #include <algorithm> #include <cstring> using namespace std; const int N = 1e5 + 10,M = 200010; int h[N],e[M],ne[M],idx; int color[N]; int n,m; void add(int a,int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } bool dfs(int u,int x) { color[u] = x; for(int i = h[u] ; i != -1 ; i = ne[i]) { int j = e[i]; if(!color[j]) { if(!dfs(j,3-x)) return false; } else if(color[j] == x) return false; } return true; } int main(void) { cin >> n >> m ; memset(h, -1, sizeof h); while(m --) { int a,b; cin >> a >> b; add(a,b),add(b,a); } bool flag = true; for(int i = 1 ;i <= n ; i ++) { if(!color[i]) { if(!dfs(i,1)) { flag = false; break; } } } if(flag) cout << \"Yes\" << endl; else cout << \"No\" << endl; return 0; }","title":"\u67d3\u8272\u6cd5\u5224\u65ad"},{"location":"algorithm/graph/#topsort-dfs-bfs","text":"","title":"Topsort Dfs Bfs"},{"location":"algorithm/graph/#topsort","text":"\u5229\u7528\u5165\u5ea6\u6765\u8fdb\u884c\u5224\u65ad \u627e\u5230\u6240\u6709\u5165\u5ea6\u4e3a 0 \u7684\u70b9\u628a\u5176\u52a0\u5165\u961f\u5217\u4e2d \u6700\u597d\u5229\u7528\u624b\u52a8\u6a21\u62df\u961f\u5217 \u8fd9\u6837\u4f1a\u5bf9\u7ed3\u679c\u7684\u8f93\u51fa\u8d77\u5230\u7b80\u5316\u4f5c\u7528 \u5728\u5faa\u73af\u4e2d\uff0c\u5982\u679c\u5b58\u5728\u5165\u5ea6\u4e3a 1 \u7684\u60c5\u51b5\u51fa\u73b0\u65f6\uff0c\u4e5f\u4f1a\u628a\u8be5\u503c\u52a0\u5165\u5230\u961f\u5217\u4e2d\uff0c\u56e0\u4e3a\u4ed6\u540c\u6837\u53ef\u4ee5\u6ee1\u8db3\u62d3\u6251\u7684\u6761\u4ef6","title":"topsort \u62d3\u6251\u6392\u5e8f"},{"location":"algorithm/graph/#dfs","text":"dfs \u4e3b\u8981\u662f\u4e00\u4e2a\u5229\u7528\u9012\u5f52\u7684\u8fc7\u7a0b \u6df1\u5ea6\u4f18\u5148\u904d\u5386 \u53ef\u4ee5\u5904\u7406\u6392\u5217\u6570\u5b57\u7b49\u95ee\u9898","title":"Dfs \u6df1\u5ea6\u4f18\u5148\u904d\u5386"},{"location":"algorithm/graph/#bfs","text":"\u5bbd\u5ea6\u4f18\u5148\u904d\u5386 bfs \u4e3b\u8981\u5229\u7528\u961f\u5217\u6765\u8fdb\u884c\u5b58\u50a8\uff0c\u5f53\u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e0d\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u4f1a\u4e00\u76f4\u7ee7\u7eed\u4e0b\u53bb\uff0c\u6bcf\u6b21\u63a8\u5165\u6ee1\u8db3\u6761\u4ef6\u7684\u70b9\uff0c\u6700\u540e\u627e\u5230\u6700\u77ed\u7684\u8def\u5f84\u6216\u8005\u662f\u8ff7\u5bab\u7684\u51fa\u8def","title":"Bfs \u5bbd\u5ea6\u4f18\u5148\u904d\u5386"},{"location":"algorithm/math/","text":"\u6570\u8bba \u8d28\u6570 \u7ea6\u6570 \u6b27\u62c9\u51fd\u6570 \u6b27\u51e0\u91cc\u5f97 \u9ad8\u65af\u6d88\u5143 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u5bb9\u65a5\u539f\u7406 \u535a\u5f08\u8bba \u7ec4\u5408\u6570\u6c42\u6cd5 \u9884\u5904\u7406\u4e4b\u540e\u8fdb\u884c\u8be2\u95ee\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O\uff081\uff09\uff1b 1\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u8f83\u591a\uff0c\u5e76\u4e14\u7ed9\u5b9a ab \u4e0d\u5927\u7684\u503c\uff0c \u53ef\u4ee5\u5229\u7528\u9012\u63a8\u8fdb\u884c \u9884\u5904\u7406 \uff0c\u5904\u7406\u51fa \u4ece C11 \u5230 Cab \u7684\u503c n2 \u5229\u7528\u4e86\u516c\u5f0f $$ C[a][b] = c[a-1][b] + c[a-1][b-1] $$ 1\u2264n\u2264100001\u2264n\u226410000, 1\u2264b\u2264a\u22642000 #include <iostream> #include <algorithm> using namespace std; const int mod = 1e9 + 7; const int N = 2010; int c[N][N]; void init() { c[1][1] = 1; for(int i = 0;i< N ; i ++) for(int j = 0; j <= i ; j++) if(!j) c[i][j] = 1; else c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int main(void) { init(); int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << c[a][b] << endl; } return 0; } 2\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u4e0d\u7b97\u7279\u522b\u591a\uff0c\u5e76\u4e14\u7ed9\u5b9a ab \u7684\u503c\u8f83\u5927\u7684\u503c \uff0c\u53ef\u4ee5\u5229\u7528\u7ec4\u5408\u6570\u7684\u9006\u63a8\uff08\u4e0a\u4e0b\u9636\u4e58\uff09 \u65b9\u5f0f\uff0c \u9884\u5904\u7406 \u51fa\u6765 \u5206\u5b50\u7684\u9636\u4e58\u548c\u5206\u6bcd\u7684\u9636\u4e58\u7684\u9006\u5143\uff0c\u7136\u540e\u76f4\u63a5\u5229\u7528\u516c\u5f0f\u8f93\u51fa res \u5373\u53ef nlogn $$ C[a][b] = a! / (b! * (a - b)!) $$ 1\u2264n\u2264100001\u2264n\u226410000, 1\u2264b\u2264a\u2264105 #include <iostream> #include <algorithm> using namespace std; typedef long long LL; const int mod = 1e9 + 7; const int N = 1e5 + 10; int fact[N],infact[N]; int qmi(int a,int k,int p) { int res = 1 % p; while(k) { if(k & 1) res =(LL) res * a % p; a = (LL) a * a % p; k = k >> 1; } return res; } int main(void) { fact[0] = infact[0] = 1; for(int i = 1; i< N ; i ++) { fact[i] = (LL)i * fact[i-1] % mod; infact[i] = (LL)infact[i - 1] * qmi(i,mod-2,mod) % mod; } int n; cin >> n; while(n --) { int a,b; cin >> a >> b; cout << (LL)fact[a] * infact[b] % mod * infact[a-b] % mod<< endl; } return 0; } 3\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u4e0d\u591a\uff0c\u7ed9\u51fa ab \u7684\u503c\u7279\u522b\u5927\u7684\u503c \uff0c\u53ef\u4ee5\u5229\u7528 lucase \u5b9a\u5f8b\u6765\u6c42\uff0c Cab = Ca%pb%p * Ca/pb/p \uff1b\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u70b9\u4e3b\u8981\u662f \u8fd4\u56de lucase \u5b9a\u5f8b\u7684\u503c\u5fc5\u987b\u65f6 lucasa/p,b/p \u56e0\u4e3a \u53ef\u80fd\u518d ab \u9664\u4ee5 p \u4e4b\u540e\u7684\u5230\u7684\u503c\u4ecd\u7136\u5927\u4e8e\u5927\u4e8ep\uff0c\u8fd9\u6837\u7684\u8bdd\u6c42 Cab \u53ef\u80fd\u4f1a\u51fa\u73b0\u9519\u8bef\uff1b \u6c42 Cab \u65f6\u5229\u7528\u7684\u516c\u5f0f\u662f\u5206\u6bcd\u5230\u5206\u5b50\u7684\u9636\u4e58\u6bd4\u4e0a\u5206\u5b50\u4ece\u4e00\u5230\u5b83\u672c\u8eab\u7684\u9636\u4e58\u5229\u7528\u9006\u5143\u6765\u6c42 $$ Cba=a!/b!(a\u2212b)!=(a\u2212b+1)\u00d7(a\u2212b+2)\u00d7\u2026\u00d7a/b! $$ #include <iostream> #include <algorithm> using namespace std; typedef long long LL; int qmi(int a, int k, int p) { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) { if (b > a) return 0; int res = 1; for (int i = 1, j = a; i <= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2, p) % p; } return res; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n -- ) { LL a, b; int p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; } 4\uff0c \u5bf9\u4e8e\u6240\u6c42\u7684\u503c\u4e0d\u8fdb\u884c \u53d6\u6a21\u7684\u8fd0\u7b97 \u5206\u4e3a\u4e09\u6b65\u8d70\uff0c\u7b2c\u4e00\u6b65\u7528\u8d28\u6570\u7b5b\u6cd5\uff0c\u7b5b\u51fa\u524dn\u4e2a\u6570\u4e2d\u7684\u8d28\u6570\uff0c\u7b2c\u4e8c\u6b65\uff0c\u5229\u7528\u9664\u6cd5\u6c42\u51fa\u6bcf\u4e2a\u6570\u8d28\u56e0\u6570\u7684\u500d\u6570\u7684\u4e2a\u6570\uff0c\u7136\u540e\u5229\u7528\u9ad8\u7cbe\u5ea6\u4e58\u6cd5\u6c42\u51fa\u6700\u7ec8p\u7684\u7ed3\u679c \u4e0a\u9762\u7684\u6570\u7684\u9636\u4e58\u548c\u4e0b\u9762\u4e24\u4e2a\u6570\u7684\u9636\u4e58\u90fd\u53ef\u4ee5\u7528\u6570\u5b66\u57fa\u672c\u5b9a\u7406\u6765\u5206\u89e3 \u7136\u540e\u518d\u4e0a\u4e0b\u518d\u53bb\u6389\u76f8\u540c\u7684\u6307\u6570\u518d\u76f8\u4e58\u5c31\u884c #include <iostream> #include <algorithm> #include <vector> using namespace std; const int N = 5010; int primes[N]; bool st[N]; int cnt; int sum[N]; void get_primes(int n) { for(int i = 2;i<=n;i++) { if(!st[i]) primes[cnt++] = i; for(int j = 0;primes[j] <=n/i;j++) { st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } } int get(int x,int p) { int res = 0; while(x) { res += x/p; x /= p; // \u4e00\u76f4\u628a p \u7684 k \u6b21\u65b9\u4e5f\u53bb\u6389 } return res; } vector<int> mul(vector<int> a,int b) { vector<int> c; int t = 0; for(int i = 0;i<a.size();i++) { t = t + a[i] *b; c.push_back(t%10); t = t/10; } while(t) { c.push_back(t%10); t = t /10; } return c; } int main(void) { int a,b; cin >> a>> b; get_primes(a); // \u7b5b\u9009\u51fa\u4e86\u8d28\u6570 for(int i = 0;i < cnt;i++) { int p = primes[i]; sum[i] = get(a,p) - get(a-b,p) - get(b,p);// \u8fd9\u91cc\u679a\u4e3e\u6240\u6709\u53ef\u80fd\u5b58\u5728\u7684\u8d28\u6570 \u5e76\u9664\u53bb \u5f97\u5230\u9664\u4e4b\u540e\u7684\u8d28\u6570\u7684\u6570\u91cf\uff1b\uff1b } vector<int> res; res.push_back(1); for(int i = 0;i<cnt;i++) for(int j = 0;j<sum[i];j++) res = mul(res,primes[i]); // \u8fd9\u91cc\u8fdb\u884c\u76f8\u4e58\uff1b\uff1b for(int i = res.size() -1; i>=0;i--) cout << res[i]; cout << endl; return 0; } \u8d28\u6570 \u8bd5\u9664\u6cd5\u6c42\u8d28\u6570 \u53ef\u4ee5\u5229\u7528 n/i \u6765\u8fdb\u884c\u4f18\u5316\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u7ea6\u6570\u90fd\u662f \u4e00\u5bf9\u4e00\u5bf9 \u7684\u51fa\u73b0\u7684\uff0cd \u80fd\u6574\u9664 n \uff0cn/d \u4e5f\u80fd\u6574\u9664 n \uff0c\u6240\u4ee5\u8bf4\u5c31\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u628a n \u6362\u6210 n/i \u6765\u7f29\u5c0f\u8303\u56f4 \uff1a \u5982\u679c n/i \u4e4b\u540e\u5b58\u5728\u6811\u4f7f x \u4e0d\u4e3a\u8d28\u6570\uff0c\u90a3\u4e48\uff0c\u5728 n/i \u4e4b\u524d\u4e00\u5b9a\u4e5f\u5b58\u5728\u8fd9\u6837\u7684\u6570 #include <iostream> #include <algorithm> using namespace std; bool check(int x) { if(x == 2 ) return true; if(x == 1 || x == 0) return false; for(int i = 2; i <= x / i ; i ++) { if(x % i == 0) return false; } return true; } int main(void) { int n; cin >> n; while(n --) { int x; cin >> x; if(check(x)) cout << \"Yes\" << endl; else cout <<\"No\" << endl; } return 0; } \u5206\u89e3\u8d28\u56e0\u6570 \u7531\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u53ef\u4ee5\u77e5\u9053\uff0c\u4efb\u4f55\u4e00\u4e2a\u6570\u90fd\u53ef\u4ee5\u5206\u89e3\u4e3a\u8d28\u6570\u7684\u6307\u6570\u5f62\u5f0f\u7684\u4e58\u79ef\u548c #include <iostream> #include <cstring> #include <algorithm> using namespace std; void get_primes(int x) { for(int i =2 ; i <= x / i ; i ++) { if(x%i == 0) { int s = 0; while( x % i == 0) { s++; x = x / i; } cout << i << \" \" << s << endl; } } if(x > 1) cout << x <<\" \" << 1 << endl; cout << endl; } int main() { int n; cin >> n; while(n--) { int x; cin >> x; get_primes(x); } return 0; } \u7b5b\u8d28\u6570 \u6734\u7d20\u505a\u6cd5\u662f\u7b5b\u6389\u6240\u6709 \u6570 \u540e\u9762\u7684\u6570 \u57c3\u5f0f\u7b5b\u6cd5\u662f\u7b5b\u6389\u6240\u6709 \u8d28\u6570 \u540e\u9762\u7684\u6570 \u7ebf\u6027\u7b5b\u6cd5\u662f\u901a\u8fc7 \u8d28\u56e0\u5b50\u6765\u7b5b\u6389\u6240\u6709\u8d28\u6570 \u540e\u9762\u7684\u6570 1e7 \u4f1a\u6bd4\u4e0a\u4e00\u4e2a\u5feb\u4e00\u500d \u7ebf\u6027\u7b5b\u6cd5 \u5224\u65ad\u6761\u4ef6 if \u6210\u7acb\u65f6\u4fdd\u8bc1\u4e86 i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u662f pj \uff0c\u540c\u65f6 i*pj \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u4e5f\u662f pj \u5f53 if \u6761\u4ef6\u4e0d\u6210\u7acb\u65f6\uff0c\u4fdd\u8bc1\u4e86 i*pj \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u662f pj\uff1b\u4e14 pj \u4e00\u5b9a\u5c0f\u4e8e i \u7684\u6240\u6709\u8d28\u56e0\u5b50 \u6bcf\u4e2a\u5408\u6570\u90fd\u4f1a\u6709\u4e00\u4e2a\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u5f53 i \u679a\u4e3e\u5230 x/i \u7684\u65f6\u5019\uff0cx \u4e00\u5b9a\u4f1a\u88ab\u7b5b\u6389 #include <iostream> #include <algorithm> using namespace std; const int N = 1e6 +10; bool st[N]; int primes[N],cnt; void get_primes(int n) { for(int i = 2; i <= n ; i++) { if(!st[i]) primes[cnt ++] = i; for(int j = 0 ; primes[j] <= n/i ; j ++) { st[i * primes[j]] = true; if(i % primes[j] == 0) break; } } } int main(void) { int n; cin >> n; get_primes(n); cout << cnt << endl; return 0; } \u7ea6\u6570 \u8bd5\u9664\u6cd5\u6c42\u7ea6\u6570 \u53ef\u4ee5\u5229\u7528 i != n/i \u6765\u8fdb\u884c\u4f18\u5316 \uff0c\u56e0\u4e3a\u8d28\u6570\u662f\u4e00\u5bf9\u4e00\u5bf9\u7684\u51fa\u73b0\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u8fd9\u4e2a\u5f0f\u5b50\u8fdb\u884c\u63d0\u524d\u7684\u5224\u65ad\uff0c\u5f97\u5230\u5927\u4e8e n/i \u7684\u7ea6\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u9632\u6b62\u51fa\u73b0\u5e73\u65b9\u6570\u76f8\u540c\u7684\u60c5\u51b5 #include <iostream> #include <algorithm> using namespace std; void get_divisors(int x) { vector<int> res ; for(int i = 1 ; i <= x/ i; i ++) { if(x % i ==0) { res.push_back(i); if(i != x/i) res.push_back(x/i); } } sort(res.begin(),res.end()); for(auto x : res) cout << x << \" \" ; cout << endl; } int main(void) { int n; cin >> n; while(n --) { int x; cin >> x; get_divisors(x); } return 0; } \u7ea6\u6570\u4e2a\u6570 \u4e00\u4e2a\u6570\u53ef\u4ee5\u6839\u636e\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u5212\u5206\u4e4b\u540e\uff0c\u7ea6\u6570\u7684\u4e2a\u6570\u5c31\u662f \u6240\u6709\u6307\u6570\u9879+1 \u7684\u4e58\u79ef\u548c\uff1b \u56e0\u4e3a\u8fd9\u4e2a\u6570\u7684\u6bcf\u4e00\u4e2a\u6570\u4e5f\u90fd\u53ef\u4ee5\u5229\u7528\u7b97\u672f\u57fa\u672c\u5b9a\u91cc\u8fdb\u884c\u5212\u5206\uff0c\u5f97\u5230\u4e0d\u540c\u7684\u8d28\u6570\u7684\u6307\u6570\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u884c +1 #include <iostream> #include <algorithm> #include <unordered_map> using namespace std; const int mod = 1e9 + 7; int n; unordered_map<int,int>primes; void get(int x) { for(int i = 2; i <= x/ i; i++) { if(x % i == 0) { while(x % i == 0) primes[i]++,x/=i; } } if(x > 1) primes[x] ++; } int main(void) { cin >> n; while(n --) { int x; cin >> x; get(x); } long long res = 1; for(auto prime : primes) res = (long long ) res * (prime.second + 1) % mod; cout << res << endl; return 0; } \u7ea6\u6570\u4e4b\u548c \u4e00\u4e2a\u6570\u53ef\u4ee5\u6839\u636e\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u5212\u5206\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8d28\u6570\u7684\u4ece\u96f6\u6b21\u65b9\u5230\u8fd9\u4e2a\u8d28\u6570\u6307\u6570\u7684\u4e58\u79ef\u548c\u518d\u76f8\u4e58\u4e4b\u540e\u7684\u5230\u7ea6\u6570\u7684\u4e4b\u548c \u56e0\u4e3a\u6bcf\u4e2a\u6570\u90fd\u53ef\u4ee5\u5229\u7528\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u4e0a\u9762\u7684\u4e58\u79ef\u5f0f\uff0c\u4e58\u5f00\u4e4b\u540e\u4ece\u96f6\u6b21\u65b9\u5230\u4ed6\u6307\u6570\u6b21\u65b9\u7684\u6240\u6709\u7ed3\u679c\u90fd\u4f1a\u51fa\u73b0\uff0c\u53c8\u56e0\u4e3a\u662f\u4e58\u79ef\u5f0f\u6240\u4ee5\u4f1a\u8fdb\u884c\u7d2f\u52a0\u4ece\u800c\u5f97\u5230\u6700\u540e\u7684\u7ed3\u679c \u4ece0\u6b21\u65b9\u5230b\u6b21\u65b9\u7684\u4e58\u79ef t = (t * a + 1)\u5faa\u73af b \u6b21\uff0ct \u4ece 1 \u5f00\u59cb #include <iostream> #include <unordered_map> #include <algorithm> using namespace std; typedef long long LL; const int mod = 1e9 +7; unordered_map<int,int> primes; void get(int x) { for(int i = 2;i <= x/i;i++) { while(x%i == 0) { x = x / i; primes[i]++; } } if(x > 1) primes[x] ++; } int main(void) { int n; cin >> n; while(n--) { int x; cin >> x; get(x); } LL res = 1; for(auto prime : primes) { LL a = prime.first; LL b = prime.second; LL t = 1; while(b -- ) t = (t * a + 1) % mod; // Important;; res = res * t %mod; } cout << res << endl; return 0; } \u6700\u5927\u516c\u7ea6\u6570 d \u80fd\u6574\u9664 a\uff0cd \u80fd\u6574\u9664 b\uff0cd \u5c31\u80fd\u6574\u9664 a+b\uff0cd \u5c31\u80fd\u6574\u9664 ax+by \u56e0\u6b64 a \u548c b \u7684\u6700\u5927\u516c\u7ea6\u6570\u5c31\u7b49\u4e0e b \u548c a%b \u7684\u6700\u5927\u516c\u7ea6\u6570 \u56e0\u4e3a a %b \u53ef\u4ee5\u770b\u6210 a - c*b \u518d\u7531\u4e0a\u9762\u7684\u5f0f\u5b50\u5f97\u51fa\u7ed3\u679c\u5373\u53ef #include <iostream> #include <algorithm> using namespace std; int gcd(int a,int b) { return b ? gcd(b,a%b) : a; } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << gcd(a,b) <<endl; } return 0; } \u6700\u5c0f\u516c\u500d\u6570 \u5c31\u662f a*b / gcd(a,b); #include <iostream> #include <algorithm> using namespace std; int gcd(int a,int b) { return b ? gcd(b,a%b) : a; } int lcm(int a,int b) { return a * b / gcd(a,b); } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << lcm(a,b) <<endl; } return 0; } **\u6b27\u62c9\u51fd\u6570 ** #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL oula(int x) { LL res = x; for(int i = 2;i <= x/i;i++) { if(x% i == 0) { while(x % i == 0) { x = x/i; } res = (LL) res / i * (i-1); } } if(x > 1) res = (LL) res / x *(x-1); return res; } int main(void) { int n; cin>> n; while(n--) { int x; cin >> x; cout << oula(x) <<endl; } return 0; } \u5bb9\u65a5\u539f\u7406 \u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570 \u5f53\u8be5\u6570\u4e3a\u8d28\u6570\u7684\u65f6\u5019\uff0c\u8be5\u6570\u7684\u6b27\u62c9\u51fd\u6570\u4e3a n-1\uff1b \u7ebf\u6027\u7b5b\u65f6\uff0c\u82e5 pj \u662f pj*i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u65f6\uff0c\u7531\u6b27\u62c9\u5b9a\u7406\u53ef\u4ee5\u77e5\u9053\u8be5\u6700\u5c0f\u8d28\u56e0\u5b50\u4e00\u5b9a\u4e58\u8fc7\u4e86\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5c06 e[i] * pj \u5373\u53ef\uff1b \u82e5 pj \u4e0d\u662f pj*i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u65f6 \u9700\u8981\u52a0\u4e0a pj * (pj - 1) / pj \u6240\u4ee5\u5f97\u5230 e[i] * (pj - 1); \u5feb\u901f\u5e42 \u628a a \u7684 k \u6b21\u65b9\u4e0a\u9762\u7684 k \u8f6c\u5316\u6210\u4e8c\u8fdb\u5236\u7684\u6570 \uff0c\u7136\u540e\u5229\u7528\u4e8c\u8fdb\u5236\u7684\u6570\u6765\u8fdb\u884c\u76f8\u4e58\u6c42\u89e3\u6700\u7ec8\u7684 ans \u5229\u7528\u5faa\u73af\u6bcf\u6b21\u4f7f a \u76f8\u4e58\u53d8\u6210\u6307\u6570\u5e73\u65b9\u5f0f\uff0c\u540c\u65f6\u6307\u6570 k \u4ece\u7b2c\u96f6\u4f4d\u5f00\u59cb\u8fdb\u884c\u5411\u524d\u8d70\uff0c\u5982\u679c\u672b\u5c3e\u7b49\u4e8e 1 \u7684\u8bdd\uff0c\u5c31\u628a res * a \u76f8\u5f53\u4e8e\u4e86 a \u7684\u591a\u5c11\u6b21\u65b9\u76f8\u4e58\u8fdb\u884c #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL qmi(int a,int k,int p) { LL res = 1; while(k) { if(k & 1) res = (LL)res * a %p; a = (LL)a*a % p; k = k >> 1; } return res; } int main(void) { int n; cin >> n; while(n--) { int a,k,p; cin >> a >> k >> p; cout << qmi(a,k,p) << endl; } return 0; } \u5feb\u901f\u5e42\u6c42\u9006\u5143 \u5feb\u901f\u5e42\u6c42\u9006\u5143\uff0c\u5f53 b \u548c p \u4e92\u8d28\u7684\u65f6\u5019\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\u53ef\u4ee5\u5f97\u5230 b \u7684 -2 \u6b21\u65b9\u5c31\u662f b \u7684\u9006\u5143 #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL qmi(int a,int k,int p) { LL res = 1; while(k) { if(k & 1) res = (LL)res * a %p; a = (LL)a*a % p; k = k >> 1; } return res; } int main(void) { int n; cin >> n; while(n--) { int a,p; cin >> a >> p; LL res = qmi(a,p-2,p); if(a % p == 0) cout << \"impossible\" << endl; else cout << res << endl; } return 0; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143 \u6c42\u51fa x \u5c31\u53ef\u4ee5\u5f97\u5230 \u9006\u5143\u4e86 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5 \u5229\u7528\u6700\u5927\u516c\u7ea6\u6570\u6765\u8f97\u8f6c\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c \u5f53 b \u4e0d\u4e3a 0 \u7684\u65f6\u5019\u5c31\u53ef\u7ee7\u7eed\u8fdb\u884c a%b \uff1b \u7ed9\u5b9a nn \u5bf9\u6b63\u6574\u6570 ai,biai,bi\uff0c\u5bf9\u4e8e\u6bcf\u5bf9\u6570\uff0c\u6c42\u51fa\u4e00\u7ec4 xi,yixi,yi\uff0c\u4f7f\u5176\u6ee1\u8db3 ai\u00d7xi+bi\u00d7yi=gcd(ai,bi)ai\u00d7xi+bi\u00d7yi=gcd(ai,bi)\u3002 \u7ed9\u51fa a,b \u6c42\u51fa x,y #include <iostream> #include <algorithm> using namespace std; int exgcd(int a,int b,int &x,int &y) { if(b == 0) { x = 1 , y = 0; return a; } int d = exgcd(b,a%b,y,x); y -= a/b * x; return d; } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; int x,y; int d = exgcd(a,b,x,y); cout << x<<\" \" << y << endl; } return 0; } \u8f93\u5165\u89c4\u6a21\u572810\u76845\u6b21\u65b9\u4ee5\u5185\uff0c\u53ef\u4ee5\u7528 cin \u548c scanf \u5dee\u522b\u4e0d\u5927 \u5927\u4e8e 10 \u7684 5 \u6b21\u65b9\u4e4b\u540e\uff0c\u7528 scanf \u53ef\u4ee5\u6bd4 cin \u5feb\u4e00\u500d\u5de6\u53f3","title":"Math"},{"location":"algorithm/math/#_1","text":"\u8d28\u6570 \u7ea6\u6570 \u6b27\u62c9\u51fd\u6570 \u6b27\u51e0\u91cc\u5f97 \u9ad8\u65af\u6d88\u5143 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u5bb9\u65a5\u539f\u7406 \u535a\u5f08\u8bba \u7ec4\u5408\u6570\u6c42\u6cd5 \u9884\u5904\u7406\u4e4b\u540e\u8fdb\u884c\u8be2\u95ee\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O\uff081\uff09\uff1b 1\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u8f83\u591a\uff0c\u5e76\u4e14\u7ed9\u5b9a ab \u4e0d\u5927\u7684\u503c\uff0c \u53ef\u4ee5\u5229\u7528\u9012\u63a8\u8fdb\u884c \u9884\u5904\u7406 \uff0c\u5904\u7406\u51fa \u4ece C11 \u5230 Cab \u7684\u503c n2 \u5229\u7528\u4e86\u516c\u5f0f $$ C[a][b] = c[a-1][b] + c[a-1][b-1] $$ 1\u2264n\u2264100001\u2264n\u226410000, 1\u2264b\u2264a\u22642000 #include <iostream> #include <algorithm> using namespace std; const int mod = 1e9 + 7; const int N = 2010; int c[N][N]; void init() { c[1][1] = 1; for(int i = 0;i< N ; i ++) for(int j = 0; j <= i ; j++) if(!j) c[i][j] = 1; else c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int main(void) { init(); int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << c[a][b] << endl; } return 0; } 2\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u4e0d\u7b97\u7279\u522b\u591a\uff0c\u5e76\u4e14\u7ed9\u5b9a ab \u7684\u503c\u8f83\u5927\u7684\u503c \uff0c\u53ef\u4ee5\u5229\u7528\u7ec4\u5408\u6570\u7684\u9006\u63a8\uff08\u4e0a\u4e0b\u9636\u4e58\uff09 \u65b9\u5f0f\uff0c \u9884\u5904\u7406 \u51fa\u6765 \u5206\u5b50\u7684\u9636\u4e58\u548c\u5206\u6bcd\u7684\u9636\u4e58\u7684\u9006\u5143\uff0c\u7136\u540e\u76f4\u63a5\u5229\u7528\u516c\u5f0f\u8f93\u51fa res \u5373\u53ef nlogn $$ C[a][b] = a! / (b! * (a - b)!) $$ 1\u2264n\u2264100001\u2264n\u226410000, 1\u2264b\u2264a\u2264105 #include <iostream> #include <algorithm> using namespace std; typedef long long LL; const int mod = 1e9 + 7; const int N = 1e5 + 10; int fact[N],infact[N]; int qmi(int a,int k,int p) { int res = 1 % p; while(k) { if(k & 1) res =(LL) res * a % p; a = (LL) a * a % p; k = k >> 1; } return res; } int main(void) { fact[0] = infact[0] = 1; for(int i = 1; i< N ; i ++) { fact[i] = (LL)i * fact[i-1] % mod; infact[i] = (LL)infact[i - 1] * qmi(i,mod-2,mod) % mod; } int n; cin >> n; while(n --) { int a,b; cin >> a >> b; cout << (LL)fact[a] * infact[b] % mod * infact[a-b] % mod<< endl; } return 0; } 3\uff0c \u5bf9\u4e8e\u8be2\u95ee\u6b21\u6570\u4e0d\u591a\uff0c\u7ed9\u51fa ab \u7684\u503c\u7279\u522b\u5927\u7684\u503c \uff0c\u53ef\u4ee5\u5229\u7528 lucase \u5b9a\u5f8b\u6765\u6c42\uff0c Cab = Ca%pb%p * Ca/pb/p \uff1b\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u70b9\u4e3b\u8981\u662f \u8fd4\u56de lucase \u5b9a\u5f8b\u7684\u503c\u5fc5\u987b\u65f6 lucasa/p,b/p \u56e0\u4e3a \u53ef\u80fd\u518d ab \u9664\u4ee5 p \u4e4b\u540e\u7684\u5230\u7684\u503c\u4ecd\u7136\u5927\u4e8e\u5927\u4e8ep\uff0c\u8fd9\u6837\u7684\u8bdd\u6c42 Cab \u53ef\u80fd\u4f1a\u51fa\u73b0\u9519\u8bef\uff1b \u6c42 Cab \u65f6\u5229\u7528\u7684\u516c\u5f0f\u662f\u5206\u6bcd\u5230\u5206\u5b50\u7684\u9636\u4e58\u6bd4\u4e0a\u5206\u5b50\u4ece\u4e00\u5230\u5b83\u672c\u8eab\u7684\u9636\u4e58\u5229\u7528\u9006\u5143\u6765\u6c42 $$ Cba=a!/b!(a\u2212b)!=(a\u2212b+1)\u00d7(a\u2212b+2)\u00d7\u2026\u00d7a/b! $$ #include <iostream> #include <algorithm> using namespace std; typedef long long LL; int qmi(int a, int k, int p) { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) { if (b > a) return 0; int res = 1; for (int i = 1, j = a; i <= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2, p) % p; } return res; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n -- ) { LL a, b; int p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; } 4\uff0c \u5bf9\u4e8e\u6240\u6c42\u7684\u503c\u4e0d\u8fdb\u884c \u53d6\u6a21\u7684\u8fd0\u7b97 \u5206\u4e3a\u4e09\u6b65\u8d70\uff0c\u7b2c\u4e00\u6b65\u7528\u8d28\u6570\u7b5b\u6cd5\uff0c\u7b5b\u51fa\u524dn\u4e2a\u6570\u4e2d\u7684\u8d28\u6570\uff0c\u7b2c\u4e8c\u6b65\uff0c\u5229\u7528\u9664\u6cd5\u6c42\u51fa\u6bcf\u4e2a\u6570\u8d28\u56e0\u6570\u7684\u500d\u6570\u7684\u4e2a\u6570\uff0c\u7136\u540e\u5229\u7528\u9ad8\u7cbe\u5ea6\u4e58\u6cd5\u6c42\u51fa\u6700\u7ec8p\u7684\u7ed3\u679c \u4e0a\u9762\u7684\u6570\u7684\u9636\u4e58\u548c\u4e0b\u9762\u4e24\u4e2a\u6570\u7684\u9636\u4e58\u90fd\u53ef\u4ee5\u7528\u6570\u5b66\u57fa\u672c\u5b9a\u7406\u6765\u5206\u89e3 \u7136\u540e\u518d\u4e0a\u4e0b\u518d\u53bb\u6389\u76f8\u540c\u7684\u6307\u6570\u518d\u76f8\u4e58\u5c31\u884c #include <iostream> #include <algorithm> #include <vector> using namespace std; const int N = 5010; int primes[N]; bool st[N]; int cnt; int sum[N]; void get_primes(int n) { for(int i = 2;i<=n;i++) { if(!st[i]) primes[cnt++] = i; for(int j = 0;primes[j] <=n/i;j++) { st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } } int get(int x,int p) { int res = 0; while(x) { res += x/p; x /= p; // \u4e00\u76f4\u628a p \u7684 k \u6b21\u65b9\u4e5f\u53bb\u6389 } return res; } vector<int> mul(vector<int> a,int b) { vector<int> c; int t = 0; for(int i = 0;i<a.size();i++) { t = t + a[i] *b; c.push_back(t%10); t = t/10; } while(t) { c.push_back(t%10); t = t /10; } return c; } int main(void) { int a,b; cin >> a>> b; get_primes(a); // \u7b5b\u9009\u51fa\u4e86\u8d28\u6570 for(int i = 0;i < cnt;i++) { int p = primes[i]; sum[i] = get(a,p) - get(a-b,p) - get(b,p);// \u8fd9\u91cc\u679a\u4e3e\u6240\u6709\u53ef\u80fd\u5b58\u5728\u7684\u8d28\u6570 \u5e76\u9664\u53bb \u5f97\u5230\u9664\u4e4b\u540e\u7684\u8d28\u6570\u7684\u6570\u91cf\uff1b\uff1b } vector<int> res; res.push_back(1); for(int i = 0;i<cnt;i++) for(int j = 0;j<sum[i];j++) res = mul(res,primes[i]); // \u8fd9\u91cc\u8fdb\u884c\u76f8\u4e58\uff1b\uff1b for(int i = res.size() -1; i>=0;i--) cout << res[i]; cout << endl; return 0; } \u8d28\u6570 \u8bd5\u9664\u6cd5\u6c42\u8d28\u6570 \u53ef\u4ee5\u5229\u7528 n/i \u6765\u8fdb\u884c\u4f18\u5316\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u7ea6\u6570\u90fd\u662f \u4e00\u5bf9\u4e00\u5bf9 \u7684\u51fa\u73b0\u7684\uff0cd \u80fd\u6574\u9664 n \uff0cn/d \u4e5f\u80fd\u6574\u9664 n \uff0c\u6240\u4ee5\u8bf4\u5c31\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u628a n \u6362\u6210 n/i \u6765\u7f29\u5c0f\u8303\u56f4 \uff1a \u5982\u679c n/i \u4e4b\u540e\u5b58\u5728\u6811\u4f7f x \u4e0d\u4e3a\u8d28\u6570\uff0c\u90a3\u4e48\uff0c\u5728 n/i \u4e4b\u524d\u4e00\u5b9a\u4e5f\u5b58\u5728\u8fd9\u6837\u7684\u6570 #include <iostream> #include <algorithm> using namespace std; bool check(int x) { if(x == 2 ) return true; if(x == 1 || x == 0) return false; for(int i = 2; i <= x / i ; i ++) { if(x % i == 0) return false; } return true; } int main(void) { int n; cin >> n; while(n --) { int x; cin >> x; if(check(x)) cout << \"Yes\" << endl; else cout <<\"No\" << endl; } return 0; } \u5206\u89e3\u8d28\u56e0\u6570 \u7531\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u53ef\u4ee5\u77e5\u9053\uff0c\u4efb\u4f55\u4e00\u4e2a\u6570\u90fd\u53ef\u4ee5\u5206\u89e3\u4e3a\u8d28\u6570\u7684\u6307\u6570\u5f62\u5f0f\u7684\u4e58\u79ef\u548c #include <iostream> #include <cstring> #include <algorithm> using namespace std; void get_primes(int x) { for(int i =2 ; i <= x / i ; i ++) { if(x%i == 0) { int s = 0; while( x % i == 0) { s++; x = x / i; } cout << i << \" \" << s << endl; } } if(x > 1) cout << x <<\" \" << 1 << endl; cout << endl; } int main() { int n; cin >> n; while(n--) { int x; cin >> x; get_primes(x); } return 0; } \u7b5b\u8d28\u6570 \u6734\u7d20\u505a\u6cd5\u662f\u7b5b\u6389\u6240\u6709 \u6570 \u540e\u9762\u7684\u6570 \u57c3\u5f0f\u7b5b\u6cd5\u662f\u7b5b\u6389\u6240\u6709 \u8d28\u6570 \u540e\u9762\u7684\u6570 \u7ebf\u6027\u7b5b\u6cd5\u662f\u901a\u8fc7 \u8d28\u56e0\u5b50\u6765\u7b5b\u6389\u6240\u6709\u8d28\u6570 \u540e\u9762\u7684\u6570 1e7 \u4f1a\u6bd4\u4e0a\u4e00\u4e2a\u5feb\u4e00\u500d \u7ebf\u6027\u7b5b\u6cd5 \u5224\u65ad\u6761\u4ef6 if \u6210\u7acb\u65f6\u4fdd\u8bc1\u4e86 i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u662f pj \uff0c\u540c\u65f6 i*pj \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u4e5f\u662f pj \u5f53 if \u6761\u4ef6\u4e0d\u6210\u7acb\u65f6\uff0c\u4fdd\u8bc1\u4e86 i*pj \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u662f pj\uff1b\u4e14 pj \u4e00\u5b9a\u5c0f\u4e8e i \u7684\u6240\u6709\u8d28\u56e0\u5b50 \u6bcf\u4e2a\u5408\u6570\u90fd\u4f1a\u6709\u4e00\u4e2a\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u5f53 i \u679a\u4e3e\u5230 x/i \u7684\u65f6\u5019\uff0cx \u4e00\u5b9a\u4f1a\u88ab\u7b5b\u6389 #include <iostream> #include <algorithm> using namespace std; const int N = 1e6 +10; bool st[N]; int primes[N],cnt; void get_primes(int n) { for(int i = 2; i <= n ; i++) { if(!st[i]) primes[cnt ++] = i; for(int j = 0 ; primes[j] <= n/i ; j ++) { st[i * primes[j]] = true; if(i % primes[j] == 0) break; } } } int main(void) { int n; cin >> n; get_primes(n); cout << cnt << endl; return 0; } \u7ea6\u6570 \u8bd5\u9664\u6cd5\u6c42\u7ea6\u6570 \u53ef\u4ee5\u5229\u7528 i != n/i \u6765\u8fdb\u884c\u4f18\u5316 \uff0c\u56e0\u4e3a\u8d28\u6570\u662f\u4e00\u5bf9\u4e00\u5bf9\u7684\u51fa\u73b0\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u8fd9\u4e2a\u5f0f\u5b50\u8fdb\u884c\u63d0\u524d\u7684\u5224\u65ad\uff0c\u5f97\u5230\u5927\u4e8e n/i \u7684\u7ea6\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u9632\u6b62\u51fa\u73b0\u5e73\u65b9\u6570\u76f8\u540c\u7684\u60c5\u51b5 #include <iostream> #include <algorithm> using namespace std; void get_divisors(int x) { vector<int> res ; for(int i = 1 ; i <= x/ i; i ++) { if(x % i ==0) { res.push_back(i); if(i != x/i) res.push_back(x/i); } } sort(res.begin(),res.end()); for(auto x : res) cout << x << \" \" ; cout << endl; } int main(void) { int n; cin >> n; while(n --) { int x; cin >> x; get_divisors(x); } return 0; } \u7ea6\u6570\u4e2a\u6570 \u4e00\u4e2a\u6570\u53ef\u4ee5\u6839\u636e\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u5212\u5206\u4e4b\u540e\uff0c\u7ea6\u6570\u7684\u4e2a\u6570\u5c31\u662f \u6240\u6709\u6307\u6570\u9879+1 \u7684\u4e58\u79ef\u548c\uff1b \u56e0\u4e3a\u8fd9\u4e2a\u6570\u7684\u6bcf\u4e00\u4e2a\u6570\u4e5f\u90fd\u53ef\u4ee5\u5229\u7528\u7b97\u672f\u57fa\u672c\u5b9a\u91cc\u8fdb\u884c\u5212\u5206\uff0c\u5f97\u5230\u4e0d\u540c\u7684\u8d28\u6570\u7684\u6307\u6570\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u884c +1 #include <iostream> #include <algorithm> #include <unordered_map> using namespace std; const int mod = 1e9 + 7; int n; unordered_map<int,int>primes; void get(int x) { for(int i = 2; i <= x/ i; i++) { if(x % i == 0) { while(x % i == 0) primes[i]++,x/=i; } } if(x > 1) primes[x] ++; } int main(void) { cin >> n; while(n --) { int x; cin >> x; get(x); } long long res = 1; for(auto prime : primes) res = (long long ) res * (prime.second + 1) % mod; cout << res << endl; return 0; } \u7ea6\u6570\u4e4b\u548c \u4e00\u4e2a\u6570\u53ef\u4ee5\u6839\u636e\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u5212\u5206\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8d28\u6570\u7684\u4ece\u96f6\u6b21\u65b9\u5230\u8fd9\u4e2a\u8d28\u6570\u6307\u6570\u7684\u4e58\u79ef\u548c\u518d\u76f8\u4e58\u4e4b\u540e\u7684\u5230\u7ea6\u6570\u7684\u4e4b\u548c \u56e0\u4e3a\u6bcf\u4e2a\u6570\u90fd\u53ef\u4ee5\u5229\u7528\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u8fdb\u884c\u5212\u5206\uff0c\u4e0a\u9762\u7684\u4e58\u79ef\u5f0f\uff0c\u4e58\u5f00\u4e4b\u540e\u4ece\u96f6\u6b21\u65b9\u5230\u4ed6\u6307\u6570\u6b21\u65b9\u7684\u6240\u6709\u7ed3\u679c\u90fd\u4f1a\u51fa\u73b0\uff0c\u53c8\u56e0\u4e3a\u662f\u4e58\u79ef\u5f0f\u6240\u4ee5\u4f1a\u8fdb\u884c\u7d2f\u52a0\u4ece\u800c\u5f97\u5230\u6700\u540e\u7684\u7ed3\u679c \u4ece0\u6b21\u65b9\u5230b\u6b21\u65b9\u7684\u4e58\u79ef t = (t * a + 1)\u5faa\u73af b \u6b21\uff0ct \u4ece 1 \u5f00\u59cb #include <iostream> #include <unordered_map> #include <algorithm> using namespace std; typedef long long LL; const int mod = 1e9 +7; unordered_map<int,int> primes; void get(int x) { for(int i = 2;i <= x/i;i++) { while(x%i == 0) { x = x / i; primes[i]++; } } if(x > 1) primes[x] ++; } int main(void) { int n; cin >> n; while(n--) { int x; cin >> x; get(x); } LL res = 1; for(auto prime : primes) { LL a = prime.first; LL b = prime.second; LL t = 1; while(b -- ) t = (t * a + 1) % mod; // Important;; res = res * t %mod; } cout << res << endl; return 0; } \u6700\u5927\u516c\u7ea6\u6570 d \u80fd\u6574\u9664 a\uff0cd \u80fd\u6574\u9664 b\uff0cd \u5c31\u80fd\u6574\u9664 a+b\uff0cd \u5c31\u80fd\u6574\u9664 ax+by \u56e0\u6b64 a \u548c b \u7684\u6700\u5927\u516c\u7ea6\u6570\u5c31\u7b49\u4e0e b \u548c a%b \u7684\u6700\u5927\u516c\u7ea6\u6570 \u56e0\u4e3a a %b \u53ef\u4ee5\u770b\u6210 a - c*b \u518d\u7531\u4e0a\u9762\u7684\u5f0f\u5b50\u5f97\u51fa\u7ed3\u679c\u5373\u53ef #include <iostream> #include <algorithm> using namespace std; int gcd(int a,int b) { return b ? gcd(b,a%b) : a; } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << gcd(a,b) <<endl; } return 0; } \u6700\u5c0f\u516c\u500d\u6570 \u5c31\u662f a*b / gcd(a,b); #include <iostream> #include <algorithm> using namespace std; int gcd(int a,int b) { return b ? gcd(b,a%b) : a; } int lcm(int a,int b) { return a * b / gcd(a,b); } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; cout << lcm(a,b) <<endl; } return 0; } **\u6b27\u62c9\u51fd\u6570 ** #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL oula(int x) { LL res = x; for(int i = 2;i <= x/i;i++) { if(x% i == 0) { while(x % i == 0) { x = x/i; } res = (LL) res / i * (i-1); } } if(x > 1) res = (LL) res / x *(x-1); return res; } int main(void) { int n; cin>> n; while(n--) { int x; cin >> x; cout << oula(x) <<endl; } return 0; } \u5bb9\u65a5\u539f\u7406 \u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570 \u5f53\u8be5\u6570\u4e3a\u8d28\u6570\u7684\u65f6\u5019\uff0c\u8be5\u6570\u7684\u6b27\u62c9\u51fd\u6570\u4e3a n-1\uff1b \u7ebf\u6027\u7b5b\u65f6\uff0c\u82e5 pj \u662f pj*i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u65f6\uff0c\u7531\u6b27\u62c9\u5b9a\u7406\u53ef\u4ee5\u77e5\u9053\u8be5\u6700\u5c0f\u8d28\u56e0\u5b50\u4e00\u5b9a\u4e58\u8fc7\u4e86\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5c06 e[i] * pj \u5373\u53ef\uff1b \u82e5 pj \u4e0d\u662f pj*i \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u65f6 \u9700\u8981\u52a0\u4e0a pj * (pj - 1) / pj \u6240\u4ee5\u5f97\u5230 e[i] * (pj - 1); \u5feb\u901f\u5e42 \u628a a \u7684 k \u6b21\u65b9\u4e0a\u9762\u7684 k \u8f6c\u5316\u6210\u4e8c\u8fdb\u5236\u7684\u6570 \uff0c\u7136\u540e\u5229\u7528\u4e8c\u8fdb\u5236\u7684\u6570\u6765\u8fdb\u884c\u76f8\u4e58\u6c42\u89e3\u6700\u7ec8\u7684 ans \u5229\u7528\u5faa\u73af\u6bcf\u6b21\u4f7f a \u76f8\u4e58\u53d8\u6210\u6307\u6570\u5e73\u65b9\u5f0f\uff0c\u540c\u65f6\u6307\u6570 k \u4ece\u7b2c\u96f6\u4f4d\u5f00\u59cb\u8fdb\u884c\u5411\u524d\u8d70\uff0c\u5982\u679c\u672b\u5c3e\u7b49\u4e8e 1 \u7684\u8bdd\uff0c\u5c31\u628a res * a \u76f8\u5f53\u4e8e\u4e86 a \u7684\u591a\u5c11\u6b21\u65b9\u76f8\u4e58\u8fdb\u884c #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL qmi(int a,int k,int p) { LL res = 1; while(k) { if(k & 1) res = (LL)res * a %p; a = (LL)a*a % p; k = k >> 1; } return res; } int main(void) { int n; cin >> n; while(n--) { int a,k,p; cin >> a >> k >> p; cout << qmi(a,k,p) << endl; } return 0; } \u5feb\u901f\u5e42\u6c42\u9006\u5143 \u5feb\u901f\u5e42\u6c42\u9006\u5143\uff0c\u5f53 b \u548c p \u4e92\u8d28\u7684\u65f6\u5019\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\u53ef\u4ee5\u5f97\u5230 b \u7684 -2 \u6b21\u65b9\u5c31\u662f b \u7684\u9006\u5143 #include <iostream> #include <algorithm> using namespace std; typedef long long LL; LL qmi(int a,int k,int p) { LL res = 1; while(k) { if(k & 1) res = (LL)res * a %p; a = (LL)a*a % p; k = k >> 1; } return res; } int main(void) { int n; cin >> n; while(n--) { int a,p; cin >> a >> p; LL res = qmi(a,p-2,p); if(a % p == 0) cout << \"impossible\" << endl; else cout << res << endl; } return 0; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143 \u6c42\u51fa x \u5c31\u53ef\u4ee5\u5f97\u5230 \u9006\u5143\u4e86 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5 \u5229\u7528\u6700\u5927\u516c\u7ea6\u6570\u6765\u8f97\u8f6c\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c \u5f53 b \u4e0d\u4e3a 0 \u7684\u65f6\u5019\u5c31\u53ef\u7ee7\u7eed\u8fdb\u884c a%b \uff1b \u7ed9\u5b9a nn \u5bf9\u6b63\u6574\u6570 ai,biai,bi\uff0c\u5bf9\u4e8e\u6bcf\u5bf9\u6570\uff0c\u6c42\u51fa\u4e00\u7ec4 xi,yixi,yi\uff0c\u4f7f\u5176\u6ee1\u8db3 ai\u00d7xi+bi\u00d7yi=gcd(ai,bi)ai\u00d7xi+bi\u00d7yi=gcd(ai,bi)\u3002 \u7ed9\u51fa a,b \u6c42\u51fa x,y #include <iostream> #include <algorithm> using namespace std; int exgcd(int a,int b,int &x,int &y) { if(b == 0) { x = 1 , y = 0; return a; } int d = exgcd(b,a%b,y,x); y -= a/b * x; return d; } int main(void) { int n; cin >> n; while(n--) { int a,b; cin >> a >> b; int x,y; int d = exgcd(a,b,x,y); cout << x<<\" \" << y << endl; } return 0; } \u8f93\u5165\u89c4\u6a21\u572810\u76845\u6b21\u65b9\u4ee5\u5185\uff0c\u53ef\u4ee5\u7528 cin \u548c scanf \u5dee\u522b\u4e0d\u5927 \u5927\u4e8e 10 \u7684 5 \u6b21\u65b9\u4e4b\u540e\uff0c\u7528 scanf \u53ef\u4ee5\u6bd4 cin \u5feb\u4e00\u500d\u5de6\u53f3","title":"\u6570\u8bba"},{"location":"algorithm/sort/","text":"sort quick_sort merge_sort","title":"sort"},{"location":"algorithm/sort/#sort","text":"quick_sort merge_sort","title":"sort"}]}